<!DOCTYPE html>
<html lang="zh">

  <head>
  <meta charset="utf-8">
  <meta name="robots" content="all,follow">
  <meta name="googlebot" content="index,follow,snippet,archive">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>ScheduledThreadPoolExecutor 源码分析 · 技术分享</title>
  <meta name="author" content="Siran Yao(姚毅晨)" />

  
  <meta name="keywords" content="线程池, 基础">
  

  <meta name="generator" content="Hugo 0.65.2" />

  
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">

  
  <link href="/css/animate.css" rel="stylesheet">

  
  
  <link href="/css/style.blue.css" rel="stylesheet" id="theme-stylesheet">
  

  
  <link href="/css/custom.css" rel="stylesheet">
  <link rel="stylesheet" href="/css/search.css" />

  
  
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
        <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  

  
  <link rel="shortcut icon" href="/img/123.png" type="image/x-icon" />
  <link rel="apple-touch-icon" href="/img/123.png" />

  
  <link href="/css/owl.carousel.css" rel="stylesheet">
  <link href="/css/owl.theme.css" rel="stylesheet">
  <link rel="alternate" href="/index.xml" type="application/rss+xml" title="Siran Yao">

  
  <link rel="stylesheet" href="/css/prism.css" />

  
  <meta property="og:title" content="ScheduledThreadPoolExecutor 源码分析" />
  <meta property="og:type" content="website" />
  <meta property="og:url" content="/blog/scheduledthreadpoolexecutor-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90//" />
  <meta property="og:image" content="/img/uugai.com_1583215700293.png" />
  <meta property="og:image:alt" content="ServiceMesher Logo" />

  
  <meta name="description" content="ScheduledThreadPoolExecutor 定义了一个延迟队列 DelayedWorkQueue，这个队列是基于二叉堆来实现的，每次都会把最快要执行的任务放入堆顶(最小堆)。">
  <meta property="og:description" content="ScheduledThreadPoolExecutor 定义了一个延迟队列 DelayedWorkQueue，这个队列是基于二叉堆来实现的，每次都会把最快要执行的任务放入堆顶(最小堆)。">
  <meta name="twitter:description" content="ScheduledThreadPoolExecutor 定义了一个延迟队列 DelayedWorkQueue，这个队列是基于二叉堆来实现的，每次都会把最快要执行的任务放入堆顶(最小堆)。">
  <meta property="og:description" content="ScheduledThreadPoolExecutor 定义了一个延迟队列 DelayedWorkQueue，这个队列是基于二叉堆来实现的，每次都会把最快要执行的任务放入堆顶(最小堆)。" />

  
  <meta name="referrer" content="never">

  
  
  <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?154337f0d95f0b110f98c1d5d7038895";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
  </script>


  
  

</head>


  <body>
  <link href="https://cdn.bootcss.com/highlight.js/9.12.0/styles/monokai.min.css" rel="stylesheet">
  <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
    <div id="all">

        <header>

          <div class="navbar-affixed-top" data-spy="affix" data-offset-top="200">

    <div class="navbar navbar-default yamm" role="navigation" id="navbar">

        <div class="container">
            <div class="navbar-header">
                <a class="navbar-brand home" href="/">
                    <img src="/img/uugai.com_1583215700293.png" alt="ScheduledThreadPoolExecutor 源码分析 logo" class="hidden-xs hidden-sm">
                    <img src="/img/uugai.com_1583215700293.png" alt="ScheduledThreadPoolExecutor 源码分析 logo" class="visible-xs visible-sm">
                    <span class="sr-only">ScheduledThreadPoolExecutor 源码分析 - 跳到主页</span>
                </a>
                <div class="navbar-buttons">
                    <button type="button" class="navbar-toggle btn-template-main" data-toggle="collapse" data-target="#navigation">
                      <span class="sr-only">切换导航</span>
                        <i class="fa fa-align-justify"></i>
                    </button>
                </div>
            </div>
            

            <div class="navbar-collapse collapse" id="navigation">
                <ul class="nav navbar-nav navbar-right">
                  
                  <li class="dropdown">
                    
                    <a href="/">主页</a>
                    
                  </li>
                  
                  <li class="dropdown">
                    
                    <a href="/blog/">博客</a>
                    
                  </li>
                  
                  <li class="dropdown">
                    
                      <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">文档 <span class="caret"></span></a>
                    <ul class="dropdown-menu">
                      
                        <li><a href="https://istio.io/">Istio官网</a></li>
                      
                        <li><a href="http://pulsar.apache.org/en/">Pulsar官网</a></li>
                      
                    </ul>
                    
                  </li>
                  
                  <li class="dropdown">
                    
                    <a href="/contact/">联系我</a>
                    
                  </li>
                  
                  
                    <li>
                        <a href="#modalSearch" data-toggle="modal" data-target="#modalSearch" style="outline: none;">
                        <span class="hidden-sm hidden-md hidden-lg">搜索</span> <span id="searchGlyph" class="glyphicon glyphicon-search"></span>
                    </a>
                    </li>
                  
                </ul>
            </div>
            

        </div>
    </div>
    

</div>




<div id="modalSearch" class="modal fade" role="dialog">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <button type="button" class="close" data-dismiss="modal">&times;</button>
        <h4 class="modal-title">博客搜索</h4>
      </div>
      <div class="modal-body">
          
<div class="aa-input-container" id="aa-input-container">
    <input type="search" id="aa-search-input" class="aa-input-search" placeholder="输入文章标题或摘要" name="search" autocomplete="off" autofocus="autofocus"/>
    <svg class="aa-input-icon" viewBox="654 -372 1664 1664">
        <path d="M1806,332c0-123.3-43.8-228.8-131.5-316.5C1586.8-72.2,1481.3-116,1358-116s-228.8,43.8-316.5,131.5  C953.8,103.2,910,208.7,910,332s43.8,228.8,131.5,316.5C1129.2,736.2,1234.7,780,1358,780s228.8-43.8,316.5-131.5  C1762.2,560.8,1806,455.3,1806,332z M2318,1164c0,34.7-12.7,64.7-38,90s-55.3,38-90,38c-36,0-66-12.7-90-38l-343-342  c-119.3,82.7-252.3,124-399,124c-95.3,0-186.5-18.5-273.5-55.5s-162-87-225-150s-113-138-150-225S654,427.3,654,332  s18.5-186.5,55.5-273.5s87-162,150-225s138-113,225-150S1262.7-372,1358-372s186.5,18.5,273.5,55.5s162,87,225,150s113,138,150,225  S2062,236.7,2062,332c0,146.7-41.3,279.7-124,399l343,343C2305.7,1098.7,2318,1128.7,2318,1164z" />
    </svg>
</div>
<script src="/js/algoliasearch.min.js"></script>
<script src="/js/autocomplete.min.js"></script>

<script>
var client = algoliasearch("X4YB3WOBNV", "d2134c5a8d250e6d3246594240c45201");
var index = client.initIndex("servicemesher");

autocomplete('#aa-search-input',
{ hint: false}, {
    source: autocomplete.sources.hits(index, {hitsPerPage: 5}),
    
    displayKey: 'name',
    
    templates: {
        
        suggestion: function(suggestion) {
            baseURL=""
            baseURL=baseURL.substring(0,baseURL.length-1)
            return '<span>' + '<a href="' + baseURL + suggestion.url+ '">' +
                suggestion._highlightResult.title.value + '</a></span>'+
                '<span>'+suggestion._highlightResult.summary.value+'</span>';
        }
    }
});
</script>

      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-default" data-dismiss="modal">关闭</button>
      </div>
    </div>
  </div>
</div>


        </header>

        <div id="heading-breadcrumbs">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <h1>ScheduledThreadPoolExecutor 源码分析</h1>
            </div>
        </div>
    </div>
</div>


        <div id="content">
            <div class="container">

                <div class="row">

                    

                    <div class="col-md-9" id="blog-post">
                        <div class="well">
                            <div class="author-category">
                            <i class="fa fa-calendar-o">
                            2020年1月5日
                            </i>
                            |
                            
                            作者 Siran
                            
                            
                            
                            |
                            5300字 | 阅读大约需要11分钟
                            </div>
                            
                            
                            <div class="author-category">
                            
                            
                            归档于 <a href="/categories/%e5%b9%b6%e5%8f%91%e7%bc%96%e7%a8%8b">并发编程</a>
                            
                            |
                            
                            
                            
                            标签
                            
                            <a style="text-transform:capitalize" href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"><i>#线程池</i></a>
                            
                            </div>
                            
                            
                        </div>
                        <div id="post-content">
                          <h3 id="问题">问题</h3>
<ul>
<li>ScheduledThreadPoolExecutor 与 Timer 执行定时任务比较，ScheduledThreadPoolExecutor 有什么优势？</li>
<li>ScheduledThreadPoolExecutor 与 ThreadPoolExecutor 的区别？</li>
<li>ScheduledThreadPoolExecutor 的任务调度方法有哪些？ 有什么区别？</li>
<li>ScheduledThreadPoolExecutor 如何实现异步执行并获取结果的？</li>
<li>ScheduledThreadPoolExecutor 中 DelayedWorkQueue的数据结构是什么？</li>
</ul>
<hr>
<h3 id="简述">简述</h3>
<blockquote>
<p>ScheduledThreadPoolExecutor 继承 ThreadPoolExecutor 重用线程池的功能：</p>
</blockquote>
<ul>
<li>相比 ThreadPoolExecutor 支持周期性任务的调度</li>
<li>ScheduledThreadPoolExecutor 基于相对时间</li>
<li>ScheduledThreadPoolExecutor 会将任务封装成 ScheduledFutureTask， 放入队列中</li>
<li>ScheduledThreadPoolExecutor 定义了一个延迟队列 DelayedWorkQueue，这个队列是基于二叉堆来实现的，每次都会把最快要执行的任务放入堆顶(最小堆)</li>
<li>ScheduledFutureTask 继承自 FutureTask，可以通过返回Future对象来异步的获取执行的结果</li>
</ul>
<blockquote>
<p>对于周期性的任务调度, JDK还有一个实现 Timer</p>
</blockquote>
<ul>
<li>Timer 是一个单线程模式的，如果在执行某个任务比较耗时，那么会影响接下来的任务</li>
<li>Timer 是基于绝对时间的，对系统时间比较敏感</li>
<li>Timer 的任务队列也是使用的二叉堆，处于栈顶的是最快要执行的任务(最小堆)</li>
<li>Timer 作为单线程，如果执行任务的过程中发生错误，那么会导致接下来的任务无法执行</li>
</ul>
<hr>
<h3 id="源码分析">源码分析</h3>
<h4 id="类图">类图</h4>
<p><img src="/img/blog/%E7%BA%BF%E7%A8%8B%E6%B1%A0/ScheduledThreadPool%E7%B1%BB%E5%9B%BE.png" alt=""></p>
<hr>
<h4 id="重要参数以及相关方法">重要参数以及相关方法</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">//当调用 #shutdown方法的时候是否要继续执行存在的周期性任务  默认是false
</span><span style="color:#75715e"></span>private <span style="color:#66d9ef">volatile</span> boolean continueExistingPeriodicTasksAfterShutdown;

<span style="color:#75715e">//当调用 #shutdown方法的时候是否要继续执行延迟任务  默认是true。只有在 调用#shutdownNow方法的时候任务才会被终止
</span><span style="color:#75715e"></span>private <span style="color:#66d9ef">volatile</span> boolean executeExistingDelayedTasksAfterShutdown <span style="color:#f92672">=</span> true;

<span style="color:#75715e">//当取消一个task的时候是否要立马的从工作队列中删除(DelayedWorkQueue) 默认是false
</span><span style="color:#75715e"></span>private <span style="color:#66d9ef">volatile</span> boolean removeOnCancel <span style="color:#f92672">=</span> false;

<span style="color:#75715e">//task的序号 根据FIFO来排序
</span><span style="color:#75715e"></span>private <span style="color:#66d9ef">static</span> final AtomicLong sequencer <span style="color:#f92672">=</span> new AtomicLong();

<span style="color:#75715e">// 接下来的方法就是设置以上的值和获取
</span><span style="color:#75715e"></span>public <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setContinueExistingPeriodicTasksAfterShutdownPolicy</span>(boolean value) {
        continueExistingPeriodicTasksAfterShutdown <span style="color:#f92672">=</span> value;
        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>value <span style="color:#f92672">&amp;&amp;</span> isShutdown())
            onShutdown();
    }

public boolean <span style="color:#a6e22e">getContinueExistingPeriodicTasksAfterShutdownPolicy</span>() {
        <span style="color:#66d9ef">return</span> continueExistingPeriodicTasksAfterShutdown;
    }

public <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setExecuteExistingDelayedTasksAfterShutdownPolicy</span>(boolean value) {
        executeExistingDelayedTasksAfterShutdown <span style="color:#f92672">=</span> value;
        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>value <span style="color:#f92672">&amp;&amp;</span> isShutdown())
            onShutdown();
    }

public boolean <span style="color:#a6e22e">getExecuteExistingDelayedTasksAfterShutdownPolicy</span>() {
        <span style="color:#66d9ef">return</span> executeExistingDelayedTasksAfterShutdown;
    }

public <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setRemoveOnCancelPolicy</span>(boolean value) {
        removeOnCancel <span style="color:#f92672">=</span> value;
    }

public boolean <span style="color:#a6e22e">getRemoveOnCancelPolicy</span>() {
        <span style="color:#66d9ef">return</span> removeOnCancel;
    }
</code></pre></div><hr>
<h4 id="构造方法">构造方法</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">public <span style="color:#a6e22e">ScheduledThreadPoolExecutor</span>(<span style="color:#66d9ef">int</span> corePoolSize) {
        super(corePoolSize, Integer.MAX_VALUE, <span style="color:#ae81ff">0</span>, NANOSECONDS,
              new DelayedWorkQueue());
    }
public <span style="color:#a6e22e">ScheduledThreadPoolExecutor</span>(<span style="color:#66d9ef">int</span> corePoolSize,
                                       ThreadFactory threadFactory) {
        super(corePoolSize, Integer.MAX_VALUE, <span style="color:#ae81ff">0</span>, NANOSECONDS,
              new DelayedWorkQueue(), threadFactory);
    }
public <span style="color:#a6e22e">ScheduledThreadPoolExecutor</span>(<span style="color:#66d9ef">int</span> corePoolSize,
                                       RejectedExecutionHandler handler) {
        super(corePoolSize, Integer.MAX_VALUE, <span style="color:#ae81ff">0</span>, NANOSECONDS,
              new DelayedWorkQueue(), handler);
    }
public <span style="color:#a6e22e">ScheduledThreadPoolExecutor</span>(<span style="color:#66d9ef">int</span> corePoolSize,
                                       ThreadFactory threadFactory,
                                       RejectedExecutionHandler handler) {
        super(corePoolSize, Integer.MAX_VALUE, <span style="color:#ae81ff">0</span>, NANOSECONDS,
              new DelayedWorkQueue(), threadFactory, handler);
    }
</code></pre></div><p><strong>因为 ScheduledThreadPoolExecutor 继承 ThreadPoolExecutor，所以这里都是调用 ThreadPoolExecutor 的构造方法。</strong></p>
<hr>
<h3 id="核心方法">核心方法</h3>
<h4 id="schedule-方法">schedule 方法</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">public ScheduledFuture<span style="color:#f92672">&lt;?&gt;</span> schedule(Runnable command,
                                       <span style="color:#66d9ef">long</span> delay,
                                       TimeUnit unit) {
        <span style="color:#66d9ef">if</span> (command <span style="color:#f92672">==</span> null <span style="color:#f92672">||</span> unit <span style="color:#f92672">==</span> null)
            throw new NullPointerException();
        <span style="color:#75715e">//&lt;1&gt; 封装成 RunnableScheduledFuture 对象
</span><span style="color:#75715e"></span>        RunnableScheduledFuture<span style="color:#f92672">&lt;?&gt;</span> t <span style="color:#f92672">=</span> decorateTask(command,
            new ScheduledFutureTask<span style="color:#f92672">&lt;</span>Void<span style="color:#f92672">&gt;</span>(command, null,
                                          triggerTime(delay, unit)));
        <span style="color:#75715e">//&lt;2&gt; 调用 #delayedExecute 方法执行任务
</span><span style="color:#75715e"></span>        delayedExecute(t);
        <span style="color:#66d9ef">return</span> t;
    }

public <span style="color:#f92672">&lt;</span>V<span style="color:#f92672">&gt;</span> ScheduledFuture<span style="color:#f92672">&lt;</span>V<span style="color:#f92672">&gt;</span> schedule(Callable<span style="color:#f92672">&lt;</span>V<span style="color:#f92672">&gt;</span> callable,
                                           <span style="color:#66d9ef">long</span> delay,
                                           TimeUnit unit) {
        <span style="color:#66d9ef">if</span> (callable <span style="color:#f92672">==</span> null <span style="color:#f92672">||</span> unit <span style="color:#f92672">==</span> null)
            throw new NullPointerException();
        RunnableScheduledFuture<span style="color:#f92672">&lt;</span>V<span style="color:#f92672">&gt;</span> t <span style="color:#f92672">=</span> decorateTask(callable,
            new ScheduledFutureTask<span style="color:#f92672">&lt;</span>V<span style="color:#f92672">&gt;</span>(callable,
                                       triggerTime(delay, unit)));
        delayedExecute(t);
        <span style="color:#66d9ef">return</span> t;
    }
</code></pre></div><p><strong>这两个 schedule 方法两个重载方法，只有第一个参数不同。Runnable 和 Callable的区别是：Runnable 没有返回值，无法抛出 Exception</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">public interface Runnable {
    public abstract <span style="color:#66d9ef">void</span> run();
}
public interface Callable<span style="color:#f92672">&lt;</span>V<span style="color:#f92672">&gt;</span> {
    V call() throws Exception;
}
</code></pre></div><p><strong>在 schedule 方法中&lt;1&gt;处 通过传入一个任务然后调用 #decorateTask 方法封装成 RunnableScheduledFuture</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">//修改或替换用于执行 runnable 的任务。此方法可重写用于管理内部任务的具体类。默认实现只返回给定任务。
</span><span style="color:#75715e"></span>protected <span style="color:#f92672">&lt;</span>V<span style="color:#f92672">&gt;</span> RunnableScheduledFuture<span style="color:#f92672">&lt;</span>V<span style="color:#f92672">&gt;</span> decorateTask(
    Runnable runnable, RunnableScheduledFuture<span style="color:#f92672">&lt;</span>V<span style="color:#f92672">&gt;</span> task) {
    <span style="color:#66d9ef">return</span> task;
}
<span style="color:#75715e">//修改或替换用于执行 callable 的任务。此方法可重写用于管理内部任务的具体类。默认实现只返回给定任务。
</span><span style="color:#75715e"></span>protected <span style="color:#f92672">&lt;</span>V<span style="color:#f92672">&gt;</span> RunnableScheduledFuture<span style="color:#f92672">&lt;</span>V<span style="color:#f92672">&gt;</span> decorateTask(
    Callable<span style="color:#f92672">&lt;</span>V<span style="color:#f92672">&gt;</span> callable, RunnableScheduledFuture<span style="color:#f92672">&lt;</span>V<span style="color:#f92672">&gt;</span> task) {
    <span style="color:#66d9ef">return</span> task;
}
</code></pre></div><p><strong>然后调用 #delayedExecute 方法来执行延迟任务最后返回 #ScheduledFuture 对象</strong></p>
<hr>
<h4 id="scheduleatfixedrate-方法">scheduleAtFixedRate 方法</h4>
<p><strong>下一次执行时间相当于是上一次的执行时间加上period，它是采用已固定的频率来执行任务</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">public ScheduledFuture<span style="color:#f92672">&lt;?&gt;</span> scheduleAtFixedRate(Runnable command,
                                                  <span style="color:#66d9ef">long</span> initialDelay,
                                                  <span style="color:#66d9ef">long</span> period,
                                                  TimeUnit unit) {
        <span style="color:#75715e">//&lt;1&gt; 校验
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (command <span style="color:#f92672">==</span> null <span style="color:#f92672">||</span> unit <span style="color:#f92672">==</span> null)
            throw new NullPointerException();
        <span style="color:#66d9ef">if</span> (period <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>)
            throw new IllegalArgumentException();
        <span style="color:#75715e">//&lt;2&gt; 封装成一个 ScheduledFutureTask
</span><span style="color:#75715e"></span>        ScheduledFutureTask<span style="color:#f92672">&lt;</span>Void<span style="color:#f92672">&gt;</span> sft <span style="color:#f92672">=</span>
            new ScheduledFutureTask<span style="color:#f92672">&lt;</span>Void<span style="color:#f92672">&gt;</span>(command,
                                          null,
                                          triggerTime(initialDelay, unit),
                                          unit.toNanos(period));
        RunnableScheduledFuture<span style="color:#f92672">&lt;</span>Void<span style="color:#f92672">&gt;</span> t <span style="color:#f92672">=</span> decorateTask(command, sft);
        sft.outerTask <span style="color:#f92672">=</span> t;
        <span style="color:#75715e">//&lt;3&gt; 调用 #delayedExecute()方法来执行延迟任务
</span><span style="color:#75715e"></span>        delayedExecute(t);
        <span style="color:#66d9ef">return</span> t;
    }
</code></pre></div><hr>
<h4 id="schedulewithfixeddelay-方法">scheduleWithFixedDelay 方法</h4>
<p><strong>与scheduleAtFixedRate方法不同的是，下一次执行时间是上一次任务执行完的系统时间加上period，因而具体执行时间不是固定的，但周期是固定的，是采用相对固定的延迟来执行任务</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">public ScheduledFuture<span style="color:#f92672">&lt;?&gt;</span> scheduleWithFixedDelay(Runnable command,
                                                     <span style="color:#66d9ef">long</span> initialDelay,
                                                     <span style="color:#66d9ef">long</span> delay,
                                                     TimeUnit unit) {
        <span style="color:#75715e">////&lt;1&gt; 校验
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (command <span style="color:#f92672">==</span> null <span style="color:#f92672">||</span> unit <span style="color:#f92672">==</span> null)
            throw new NullPointerException();
        <span style="color:#66d9ef">if</span> (delay <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>)
            throw new IllegalArgumentException();
        <span style="color:#75715e">//&lt;2&gt; 封装成一个 ScheduledFutureTask
</span><span style="color:#75715e"></span>        ScheduledFutureTask<span style="color:#f92672">&lt;</span>Void<span style="color:#f92672">&gt;</span> sft <span style="color:#f92672">=</span>
            new ScheduledFutureTask<span style="color:#f92672">&lt;</span>Void<span style="color:#f92672">&gt;</span>(command,
                                          null,
                                          triggerTime(initialDelay, unit),
                                          unit.toNanos(<span style="color:#f92672">-</span>delay));
        RunnableScheduledFuture<span style="color:#f92672">&lt;</span>Void<span style="color:#f92672">&gt;</span> t <span style="color:#f92672">=</span> decorateTask(command, sft);
        sft.outerTask <span style="color:#f92672">=</span> t;
        <span style="color:#75715e">//&lt;3&gt; 调用 #delayedExecute()方法来执行延迟任务
</span><span style="color:#75715e"></span>        delayedExecute(t);
        <span style="color:#66d9ef">return</span> t;
    }
</code></pre></div><hr>
<h4 id="execute-方法">execute 方法</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">//立即执行 也就是把 delay 时间置为 0
</span><span style="color:#75715e"></span>public <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">execute</span>(Runnable command) {
        schedule(command, <span style="color:#ae81ff">0</span>, NANOSECONDS);
    }
</code></pre></div><hr>
<h4 id="submit-方法">submit 方法</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">//也是调用了 schedule 方法
</span><span style="color:#75715e"></span>public Future<span style="color:#f92672">&lt;?&gt;</span> submit(Runnable task) {
        <span style="color:#66d9ef">return</span> schedule(task, <span style="color:#ae81ff">0</span>, NANOSECONDS);
    }
public <span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> Future<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> submit(Runnable task, T result) {
        <span style="color:#66d9ef">return</span> schedule(Executors.callable(task, result), <span style="color:#ae81ff">0</span>, NANOSECONDS);
    }
public <span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> Future<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> submit(Callable<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> task) {
        <span style="color:#66d9ef">return</span> schedule(task, <span style="color:#ae81ff">0</span>, NANOSECONDS);
    }
</code></pre></div><hr>
<h4 id="shutdownshutdownnowgetqueue-方法">shutdown、shutdownNow、getQueue 方法</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">public <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">shutdown</span>() {
        super.shutdown();
    }
public List<span style="color:#f92672">&lt;</span>Runnable<span style="color:#f92672">&gt;</span> shutdownNow() {
        <span style="color:#66d9ef">return</span> super.shutdownNow();
    }
public BlockingQueue<span style="color:#f92672">&lt;</span>Runnable<span style="color:#f92672">&gt;</span> getQueue() {
        <span style="color:#66d9ef">return</span> super.getQueue();
    }
</code></pre></div><p><strong>这些方法都是直接调用父类 ThreadPoolExecutor 中的实现。</strong></p>
<hr>
<h4 id="onshutdown-方法">onShutdown 方法</h4>
<p><strong>复写 ThreadPoolExecutor 中的 onShutdown 方法</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#960050;background-color:#1e0010">@</span>Override <span style="color:#66d9ef">void</span> onShutdown() {
        BlockingQueue<span style="color:#f92672">&lt;</span>Runnable<span style="color:#f92672">&gt;</span> q <span style="color:#f92672">=</span> super.getQueue();
        <span style="color:#75715e">// 获取在线程池已 shutdown 的情况下是否继续执行现有延迟任务
</span><span style="color:#75715e"></span>        boolean keepDelayed <span style="color:#f92672">=</span>
            getExecuteExistingDelayedTasksAfterShutdownPolicy();
        <span style="color:#75715e">// 获取在线程池已 shutdown 的情况下是否继续执行现有定期任务
</span><span style="color:#75715e"></span>        boolean keepPeriodic <span style="color:#f92672">=</span>
            getContinueExistingPeriodicTasksAfterShutdownPolicy();
        <span style="color:#75715e">// 如果在线程池已 shutdown 的情况下不继续执行延迟任务和定期任务
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 则依次取消任务，否则则根据取消状态来判断
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>keepDelayed <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>keepPeriodic) {
            <span style="color:#66d9ef">for</span> (Object e : q.toArray())
                <span style="color:#66d9ef">if</span> (e instanceof RunnableScheduledFuture<span style="color:#f92672">&lt;?&gt;</span>)
                    ((RunnableScheduledFuture<span style="color:#f92672">&lt;?&gt;</span>) e).cancel(false);
            q.clear();
        }
        <span style="color:#66d9ef">else</span> {
            <span style="color:#75715e">// Traverse snapshot to avoid iterator exceptions
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">for</span> (Object e : q.toArray()) {
                <span style="color:#66d9ef">if</span> (e instanceof RunnableScheduledFuture) {
                    RunnableScheduledFuture<span style="color:#f92672">&lt;?&gt;</span> t <span style="color:#f92672">=</span>
                        (RunnableScheduledFuture<span style="color:#f92672">&lt;?&gt;</span>)e;
                    <span style="color:#75715e">// 如果有在 shutdown 后不继续的延迟任务或周期任务，则从队列中删除并取消任务
</span><span style="color:#75715e"></span>                    <span style="color:#66d9ef">if</span> ((t.isPeriodic() <span style="color:#f92672">?</span> <span style="color:#f92672">!</span>keepPeriodic : <span style="color:#f92672">!</span>keepDelayed) <span style="color:#f92672">||</span>
                        t.isCancelled()) { <span style="color:#75715e">// also remove if already cancelled
</span><span style="color:#75715e"></span>                        <span style="color:#66d9ef">if</span> (q.remove(t))
                            t.cancel(false);
                    }
                }
            }
        }
        tryTerminate();
    }
</code></pre></div><hr>
<h4 id="delayedexecute-方法">delayedExecute 方法</h4>
<p><strong>上述的调度方法最终都是调用此方法来执行延迟任务</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">private <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">delayedExecute</span>(RunnableScheduledFuture<span style="color:#f92672">&lt;?&gt;</span> task) {
        <span style="color:#75715e">//&lt;1&gt; 判断是否已经处于shutdown状态
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (isShutdown())
            <span style="color:#75715e">//&lt;1.1&gt; 如果是的话 拒绝此task
</span><span style="color:#75715e"></span>            reject(task);
        <span style="color:#66d9ef">else</span> {
            <span style="color:#75715e">//&lt;2&gt; 往队列中添加此task
</span><span style="color:#75715e"></span>            super.getQueue().add(task);
            <span style="color:#75715e">//&lt;3&gt; 如果这时候被关闭了，根据continueExistingPeriodicTasksAfterShutdown或者executeExistingDelayedTasksAfterShutdown进行判断
</span><span style="color:#75715e"></span>            <span style="color:#75715e">//    是否在shutdown状态下继续完成此task，如果不是。那么移出取消此task
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (isShutdown() <span style="color:#f92672">&amp;&amp;</span>
                <span style="color:#f92672">!</span>canRunInCurrentRunState(task.isPeriodic()) <span style="color:#f92672">&amp;&amp;</span>
                remove(task))
                task.cancel(false);
            <span style="color:#66d9ef">else</span>
                <span style="color:#75715e">//&lt;4&gt; 在threadPoolExecutor 中实现，当前线程少于corePoolSize那就添加一个，如果池子中没有线程那添加一个现车过确保线程池中有一个线程
</span><span style="color:#75715e"></span>                ensurePrestart();
        }
    }
</code></pre></div><p><strong>也就是说 ScheduledThreadPoolExecutor 最终执行任务其实和还是是让 ThreadPoolExecutor 去执行
ScheduledThreadPoolExecutor 和 ThreadPoolExecutor 的区别在于，ThreadPoolExecutor 是通过不断的从阻塞队列中取出 Runnable 类型的任务并执行。
而 ScheduledThreadPoolExecutor 是不断的从延迟队列 DelayedWorkQueue 中取出 ScheduledFutureTask 类型的任务来执行，来实现周期性调度的功能。</strong></p>
<hr>
<h4 id="scheduledfuturetask">ScheduledFutureTask</h4>
<p><strong>ScheduledThreadPoolExecutor 的内部类</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">    private class ScheduledFutureTask<span style="color:#f92672">&lt;</span>V<span style="color:#f92672">&gt;</span>
            extends FutureTask<span style="color:#f92672">&lt;</span>V<span style="color:#f92672">&gt;</span> implements RunnableScheduledFuture<span style="color:#f92672">&lt;</span>V<span style="color:#f92672">&gt;</span> {
        <span style="color:#75715e">//任务的序号 不断自增 FIFO
</span><span style="color:#75715e"></span>        private final <span style="color:#66d9ef">long</span> sequenceNumber;
        <span style="color:#75715e">//以毫微秒为单位的执行任务的时间
</span><span style="color:#75715e"></span>        private <span style="color:#66d9ef">long</span> time;
        <span style="color:#75715e">//如果为正数那么表示fixed-rate，负数表示fixed-delay，0表示不是周期任务
</span><span style="color:#75715e"></span>        private final <span style="color:#66d9ef">long</span> period;
        RunnableScheduledFuture<span style="color:#f92672">&lt;</span>V<span style="color:#f92672">&gt;</span> outerTask <span style="color:#f92672">=</span> this;
        <span style="color:#75715e">//进入延迟队列的index，在二叉堆中可以快速找到并且取消 时间复杂度为O(logn)
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> heapIndex;

        <span style="color:#75715e">//构造
</span><span style="color:#75715e"></span>        ScheduledFutureTask(Runnable r, V result, <span style="color:#66d9ef">long</span> ns) {
            super(r, result);
            this.time <span style="color:#f92672">=</span> ns;
            this.period <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
            this.sequenceNumber <span style="color:#f92672">=</span> sequencer.getAndIncrement();
        }
        ScheduledFutureTask(Runnable r, V result, <span style="color:#66d9ef">long</span> ns, <span style="color:#66d9ef">long</span> period) {
            super(r, result);
            this.time <span style="color:#f92672">=</span> ns;
            this.period <span style="color:#f92672">=</span> period;
            this.sequenceNumber <span style="color:#f92672">=</span> sequencer.getAndIncrement();
        }
        ScheduledFutureTask(Callable<span style="color:#f92672">&lt;</span>V<span style="color:#f92672">&gt;</span> callable, <span style="color:#66d9ef">long</span> ns) {
            super(callable);
            this.time <span style="color:#f92672">=</span> ns;
            this.period <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
            this.sequenceNumber <span style="color:#f92672">=</span> sequencer.getAndIncrement();
        }

        <span style="color:#75715e">//获取该任务还剩多少延迟时间
</span><span style="color:#75715e"></span>        public <span style="color:#66d9ef">long</span> getDelay(TimeUnit unit) {
            <span style="color:#66d9ef">return</span> unit.convert(time <span style="color:#f92672">-</span> now(), NANOSECONDS);
        } 
        <span style="color:#75715e">//此compareTo 根据 ScheduledFutureTask 中的time 执行时间来选出最快时间的任务， 用于二叉堆(最小堆)
</span><span style="color:#75715e"></span>        public <span style="color:#66d9ef">int</span> compareTo(Delayed other) {
            <span style="color:#66d9ef">if</span> (other <span style="color:#f92672">==</span> this) <span style="color:#75715e">// compare zero if same object
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
            <span style="color:#66d9ef">if</span> (other instanceof ScheduledFutureTask) {
                ScheduledFutureTask<span style="color:#f92672">&lt;?&gt;</span> x <span style="color:#f92672">=</span> (ScheduledFutureTask<span style="color:#f92672">&lt;?&gt;</span>)other;
                <span style="color:#66d9ef">long</span> diff <span style="color:#f92672">=</span> time <span style="color:#f92672">-</span> x.time;
                <span style="color:#66d9ef">if</span> (diff <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>)
                    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
                <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (diff <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>)
                    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
                <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (sequenceNumber <span style="color:#f92672">&lt;</span> x.sequenceNumber)
                    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
                <span style="color:#66d9ef">else</span>
                    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
            }
            <span style="color:#66d9ef">long</span> diff <span style="color:#f92672">=</span> getDelay(NANOSECONDS) <span style="color:#f92672">-</span> other.getDelay(NANOSECONDS);
            <span style="color:#66d9ef">return</span> (diff <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) <span style="color:#f92672">?</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">:</span> (diff <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) <span style="color:#f92672">?</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">0</span>;
        }

        <span style="color:#75715e">//判断是否是周期性任务
</span><span style="color:#75715e"></span>        public boolean isPeriodic() {
            <span style="color:#66d9ef">return</span> period <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>;
        }

        <span style="color:#75715e">//设置下次执行的时间
</span><span style="color:#75715e"></span>        private <span style="color:#66d9ef">void</span> setNextRunTime() {
            <span style="color:#66d9ef">long</span> p <span style="color:#f92672">=</span> period;
            <span style="color:#66d9ef">if</span> (p <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>)
                time <span style="color:#f92672">+=</span> p;
            <span style="color:#66d9ef">else</span>
                time <span style="color:#f92672">=</span> triggerTime(<span style="color:#f92672">-</span>p);
        }

        <span style="color:#75715e">//取消任务
</span><span style="color:#75715e"></span>        public boolean cancel(boolean mayInterruptIfRunning) {
            boolean cancelled <span style="color:#f92672">=</span> super.cancel(mayInterruptIfRunning);
            <span style="color:#66d9ef">if</span> (cancelled <span style="color:#f92672">&amp;&amp;</span> removeOnCancel <span style="color:#f92672">&amp;&amp;</span> heapIndex <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>)
                remove(this);
            <span style="color:#66d9ef">return</span> cancelled;
        }

        <span style="color:#75715e">//对标Runnable中的run方法
</span><span style="color:#75715e"></span>        public <span style="color:#66d9ef">void</span> run() {
            boolean periodic <span style="color:#f92672">=</span> isPeriodic();
            <span style="color:#75715e">//&lt;1&gt; 根据状态判断是否满足执行的条件，不满足就取消任务
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>canRunInCurrentRunState(periodic))
                cancel(false);
            <span style="color:#75715e">//&lt;2&gt;  如果不是周期性任务，调用FutureTask中的run方法执行
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (<span style="color:#f92672">!</span>periodic)
                ScheduledFutureTask.super.run();
            <span style="color:#75715e">//&lt;3&gt; 如果是周期性任务，调用FutureTask中的runAndReset方法执
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (ScheduledFutureTask.super.runAndReset()) {
                <span style="color:#75715e">//&lt;3.1&gt; 计算下次执行该任务的时间
</span><span style="color:#75715e"></span>                setNextRunTime();
                <span style="color:#75715e">//&lt;3.2&gt; 重复执行任务
</span><span style="color:#75715e"></span>                reExecutePeriodic(outerTask);
            }
        }
    }
</code></pre></div><hr>
<h4 id="delayedworkqueue">DelayedWorkQueue</h4>
<p><strong>ScheduledThreadPoolExecutor之所以要自己实现阻塞的工作队列，在执行定时任务的时候，每个任务的执行时间都不同，
所以DelayedWorkQueue的工作就是按照执行时间的升序来排列，执行时间距离当前时间越近的任务在队列的前面,那这种优先队列的模式。
它可以保证每次出队的任务都是当前队列中执行时间最靠前的，由于它是基于堆结构的队列，堆结构在执行插入和删除操作时的最坏时间复杂度是 O(logN)。</strong></p>
<hr>
<h4 id="参数">参数</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">//初始容量
</span><span style="color:#75715e"></span>private <span style="color:#66d9ef">static</span> final <span style="color:#66d9ef">int</span> INITIAL_CAPACITY <span style="color:#f92672">=</span> <span style="color:#ae81ff">16</span>;
<span style="color:#75715e">//RunnableScheduledFuture类型的数组
</span><span style="color:#75715e"></span>private RunnableScheduledFuture<span style="color:#f92672">&lt;?&gt;</span>[] queue <span style="color:#f92672">=</span> new RunnableScheduledFuture<span style="color:#f92672">&lt;?&gt;</span>[INITIAL_CAPACITY];
<span style="color:#75715e">//锁
</span><span style="color:#75715e"></span>private final ReentrantLock lock <span style="color:#f92672">=</span> new ReentrantLock();
<span style="color:#75715e">//数量
</span><span style="color:#75715e"></span>private <span style="color:#66d9ef">int</span> size <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
<span style="color:#75715e">// leader线程
</span><span style="color:#75715e"></span>private Thread leader <span style="color:#f92672">=</span> null;
<span style="color:#75715e">// 条件队列：当较新的任务在队列的头部可用时，或者新线程可能需要成为leader，则通过该条件发出信号
</span><span style="color:#75715e"></span>private final Condition available <span style="color:#f92672">=</span> lock.newCondition();
</code></pre></div><p><strong>所有线程会有三种身份中的一种：leader和follower，以及一个干活中的状态：proccesser。它的基本原则就是，永远最多只有一个leader。而所有follower都在等待成为leader。线程池启动时会自动产生一个Leader负责等待网络IO事件，当有一个事件产生时，Leader线程首先通知一个Follower线程将其提拔为新的Leader，然后自己就去干活了，去处理这个网络事件，处理完毕后加入Follower线程等待队列，等待下次成为Leader。这种方法可以增强CPU高速缓存相似性，及消除动态内存分配和线程间的数据交换。</strong></p>
<p><a href="https://blog.csdn.net/goldlevi/article/details/7705180">参考自https://blog.csdn.net/goldlevi/article/details/7705180</a></p>
<hr>
<h4 id="offer-方法">offer 方法</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">public boolean <span style="color:#a6e22e">offer</span>(Runnable x) {
            <span style="color:#66d9ef">if</span> (x <span style="color:#f92672">==</span> null)
                throw new NullPointerException();
            RunnableScheduledFuture<span style="color:#f92672">&lt;?&gt;</span> e <span style="color:#f92672">=</span> (RunnableScheduledFuture<span style="color:#f92672">&lt;?&gt;</span>)x;
            final ReentrantLock lock <span style="color:#f92672">=</span> this.lock;
            <span style="color:#75715e">// 加锁
</span><span style="color:#75715e"></span>            lock.lock();
            try {
                <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> size;
                <span style="color:#75715e">// queue是一个RunnableScheduledFuture类型的数组，如果容量不够需要扩容
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">&gt;=</span> queue.length)
                    grow();
                size <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
                <span style="color:#75715e">// i == 0 说明堆中还没有数据
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
                    queue[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> e;
                    setIndex(e, <span style="color:#ae81ff">0</span>);
                } <span style="color:#66d9ef">else</span> {
                    <span style="color:#75715e">// i != 0 时，自下而上进行堆化
</span><span style="color:#75715e"></span>                    siftUp(i, e);
                }
                <span style="color:#75715e">// 如果传入的任务已经是队列的第一个节点了，这时available需要发出信号
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> (queue[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> e) {
                    <span style="color:#75715e">// leader设置为null为了使在take方法中的线程在通过available.signal();后会执行available.awaitNanos(delay);
</span><span style="color:#75715e"></span>                    leader <span style="color:#f92672">=</span> null;
                    available.signal();
                }
            } finally {
                lock.unlock();
            }
            <span style="color:#66d9ef">return</span> true;
        }
</code></pre></div><hr>
<h4 id="take-方法">take 方法</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">public RunnableScheduledFuture<span style="color:#f92672">&lt;?&gt;</span> take() throws InterruptedException {
            final ReentrantLock lock <span style="color:#f92672">=</span> this.lock;
            lock.lockInterruptibly();
            try {
                <span style="color:#66d9ef">for</span> (;;) {
                    RunnableScheduledFuture<span style="color:#f92672">&lt;?&gt;</span> first <span style="color:#f92672">=</span> queue[<span style="color:#ae81ff">0</span>];
                    <span style="color:#75715e">// 当堆中没有数据 等待元素插入后被唤醒
</span><span style="color:#75715e"></span>                    <span style="color:#66d9ef">if</span> (first <span style="color:#f92672">==</span> null)
                        available.await();
                    <span style="color:#66d9ef">else</span> {
                        <span style="color:#75715e">// 计算当前时间到执行时间的时间间隔
</span><span style="color:#75715e"></span>                        <span style="color:#66d9ef">long</span> delay <span style="color:#f92672">=</span> first.getDelay(NANOSECONDS);
                        <span style="color:#66d9ef">if</span> (delay <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>)
                            <span style="color:#66d9ef">return</span> finishPoll(first);
                        first <span style="color:#f92672">=</span> null; <span style="color:#75715e">// don&#39;t retain ref while waiting
</span><span style="color:#75715e"></span>                        <span style="color:#75715e">// leader不为空，阻塞线程
</span><span style="color:#75715e"></span>                        <span style="color:#66d9ef">if</span> (leader <span style="color:#f92672">!=</span> null)
                            available.await();
                        <span style="color:#66d9ef">else</span> {
                            <span style="color:#75715e">// leader为空，则把leader设置为当前线程，
</span><span style="color:#75715e"></span>                            Thread thisThread <span style="color:#f92672">=</span> Thread.currentThread();
                            leader <span style="color:#f92672">=</span> thisThread;
                            try {
                                <span style="color:#75715e">// 阻塞到执行时间
</span><span style="color:#75715e"></span>                                available.awaitNanos(delay);
                            } finally {
                                <span style="color:#75715e">// 设置leader = null，让其他线程执行available.awaitNanos(delay);
</span><span style="color:#75715e"></span>                                <span style="color:#66d9ef">if</span> (leader <span style="color:#f92672">==</span> thisThread)
                                    leader <span style="color:#f92672">=</span> null;
                            }
                        }
                    }
                }
            } finally {
                <span style="color:#75715e">// 如果leader不为空，则说明leader的线程正在执行available.awaitNanos(delay);
</span><span style="color:#75715e"></span>                <span style="color:#75715e">// 如果queue[0] == null，说明队列为空
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> (leader <span style="color:#f92672">==</span> null <span style="color:#f92672">&amp;&amp;</span> queue[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">!=</span> null)
                    available.signal();
                lock.unlock();
            }
        }
</code></pre></div><blockquote>
<p>ThreadPoolExecutor中，getTask方法，工作线程会循环地从workQueue中取任务。但定时任务却不同，因为如果一旦getTask方法取出了任务就开始执行了，而这时可能还没有到执行的时间，所以在take方法中，要保证只有在到指定的执行时间的时候任务才可以被取走。</p>
</blockquote>
<blockquote>
<p>这里的leader是为了减少不必要的定时等待，当一个线程成为leader时，它只等待下一个节点的时间间隔，但其它线程无限期等待。 leader线程必须在从take（）或poll（）返回之前signal其它线程，除非其他线程成为了leader。</p>
</blockquote>
<blockquote>
<p>试想一下，如果没有leader，那么在执行take时，都要执行available.awaitNanos(delay)，假设当前线程执行了该段代码，这时还没有signal，第二个线程也执行了该段代码，则第二个线程也要被阻塞。多个这时执行该段代码是没有作用的，因为只能有一个线程会从take中返回queue[0]（因为有lock），其他线程这时再返回for循环执行时取的queue[0]，已经不是之前的queue[0]了，然后又要继续阻塞。
所以，为了不让多个线程频繁的做无用的定时等待，这里增加了leader，如果leader不为空，则说明队列中第一个节点已经在等待出队，这时其它的线程会一直阻塞，减少了无用的阻塞（注意，在finally中调用了signal()来唤醒一个线程，而不是signalAll()）。</p>
</blockquote>
<p>其他方法和PriorityQueue 以及 DelayQueue都类似。</p>
<h3 id="总结">总结</h3>
<ul>
<li><strong>ScheduledThreadPoolExecutor 继承自 ThreadPoolExecutor，所以它也是一个线程池，也有 corePoolSize 和 workQueue，ScheduledThreadPoolExecutor 特殊的地方在于，自己实现了优先工作队列 DelayedWorkQueue</strong></li>
<li><strong>ScheduledThreadPoolExecutor 实现了 ScheduledExecutorService，所以就有了任务调度的方法，如schedule，scheduleAtFixedRate 和 scheduleWithFixedDelay</strong></li>
<li><strong>内部类ScheduledFutureTask 继承自 FutureTask，实现了任务的异步执行并且可以获取返回结果。同时也实现了Delayed接口，可以通过getDelay方法获取将要执行的时间间隔</strong></li>
<li><strong>周期任务的执行其实是调用了FutureTask类中的runAndReset方法，每次执行完设置下一次的执行时间周而复始</strong></li>
<li><strong>DelayedWorkQueue的数据结构，它是一个基于最小堆结构的优先队列，并且每次出队时能够保证取出的任务是当前队列中下次执行时间最小的任务。堆结构只保证了子节点的值要比父节点的值要大，但是不保证在整个堆中都是有序的</strong></li>
</ul>

                        </div>
                        
                        
                        
                        
                        <ul class="pager blog-pager">
                        
                        <li class="previous">
                        <a href="/blog/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8F%82%E6%95%B0-keepalivetime/" data-toggle="tooltip" data-placement="top" title="线程池参数—— KeepAliveTime">&larr; 上一篇</a>
                        </li>
                         
                        <li class="next">
                        <a href="/blog/forkjoinpool-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" data-toggle="tooltip" data-placement="top" title="ForkJoinPool 源码分析">下一篇 &rarr;</a>
                        </li>
                        
                        </ul>
                        
                        
                        


                    </div>
                    

                    

                    

                    <div class="col-md-3">

                        

                        <div class="panel panel-default sidebar-menu">
     
    <div class="panel-heading">
     <h3 class="panel-title">相关文章</h3>
    </div>
    <div class="panel-body">
     <ul class="nav nav-pills nav-stacked">
        
        <li><a href="/blog/completablefuture-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><i class="fa fa-link"></i>CompletableFuture 源码分析</a></li>
         
        <li><a href="/blog/executors-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><i class="fa fa-link"></i>Executors 源码分析</a></li>
         
        <li><a href="/blog/forkjoinpool-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><i class="fa fa-link"></i>ForkJoinPool 源码分析</a></li>
         
        <li><a href="/blog/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8F%82%E6%95%B0-keepalivetime/"><i class="fa fa-link"></i>线程池参数—— KeepAliveTime</a></li>
         
        <li><a href="/blog/semaphore-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><i class="fa fa-link"></i>Semaphore 源码分析</a></li>
         
     </ul>
    </div>
     
</div>





<div class="panel panel-default sidebar-menu">

    <div class="panel-heading">
      <h3 class="panel-title">分类</h3>
    </div>

    <div class="panel-body">
        <ul class="nav nav-pills nav-stacked">
            
            <li><a href="/categories/java%e5%9f%ba%e7%a1%80"><i class="fa fa-navicon"></i>java基础 (9)</a>
            </li>
            
            <li><a href="/categories/kafka"><i class="fa fa-navicon"></i>kafka (1)</a>
            </li>
            
            <li><a href="/categories/rpc"><i class="fa fa-navicon"></i>rpc (1)</a>
            </li>
            
            <li><a href="/categories/spring"><i class="fa fa-navicon"></i>spring (1)</a>
            </li>
            
            <li><a href="/categories/%e5%88%86%e5%b8%83%e5%bc%8f"><i class="fa fa-navicon"></i>分布式 (10)</a>
            </li>
            
            <li><a href="/categories/%e5%b9%b6%e5%8f%91%e7%bc%96%e7%a8%8b"><i class="fa fa-navicon"></i>并发编程 (29)</a>
            </li>
            
            <li><a href="/categories/%e5%be%ae%e6%9c%8d%e5%8a%a1"><i class="fa fa-navicon"></i>微服务 (5)</a>
            </li>
            
            <li><a href="/categories/%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97"><i class="fa fa-navicon"></i>消息队列 (4)</a>
            </li>
            
            <li><a href="/categories/%e7%ae%97%e6%b3%95"><i class="fa fa-navicon"></i>算法 (3)</a>
            </li>
            
            <li><a href="/categories/%e8%ae%a1%e7%ae%97%e6%9c%ba"><i class="fa fa-navicon"></i>计算机 (7)</a>
            </li>
            
        </ul>
    </div>
</div>







                        

                    </div>
                    

                    

                </div>
                

            </div>
            
        </div>
        

        <footer id="footer">
    <div class="container">

        
        <div class="col-md-4 col-sm-6">
            <h4>关于我</h4>

            <p>想当程序员的程序员</p>

            <hr class="hidden-md hidden-lg hidden-sm">

            <h4>友情连接</h4>

            <p>&nbsp;<a href="https://www.theyann.xyz:8123/home.html"> theyann</a></p>

            <hr class="hidden-md hidden-lg hidden-sm">

        </div>
        
        

        <div class="col-md-4 col-sm-6">

             
            <h4>最新博客</h4>

            <div class="blog-entries">
                
                <div class="item same-height-row clearfix">
                    <div class="image same-height-always">
                        <a href="/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/">
                            
                            <img src="/img/blog/banners/00704eQkgy1fs2ua9kohvj30rs0kub29.jpg" class="img-responsive" alt="计算机之IO">
                            
                        </a>
                    </div>
                    <div class="name same-height-always">
                        <h5><a href="/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/">计算机之IO</a></h5>
                    </div>
                </div>
                
                <div class="item same-height-row clearfix">
                    <div class="image same-height-always">
                        <a href="/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">
                            
                            <img src="/img/blog/banners/00704eQkgy1fs2ua9kohvj30rs0kub29.jpg" class="img-responsive" alt="计算机之文件系统">
                            
                        </a>
                    </div>
                    <div class="name same-height-always">
                        <h5><a href="/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">计算机之文件系统</a></h5>
                    </div>
                </div>
                
                <div class="item same-height-row clearfix">
                    <div class="image same-height-always">
                        <a href="/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">
                            
                            <img src="/img/blog/banners/006tKfTcgy1ftpqcrh9xoj30rs0kuq8z.jpg" class="img-responsive" alt="计算机之内存管理">
                            
                        </a>
                    </div>
                    <div class="name same-height-always">
                        <h5><a href="/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">计算机之内存管理</a></h5>
                    </div>
                </div>
                
            </div>

            <hr class="hidden-md hidden-lg">
             

        </div>
        

        
        <div class="col-md-4 col-sm-6 ">

            <h4>联系</h4>

            <p>个人微信</br>请备注姓名-公司信息</p><p><img src="/img/1.png"></p>
      

            <a href="/contact" class="btn btn-small btn-template-main">跳到联系页面</a>

            <hr class="hidden-md hidden-lg hidden-sm">

        </div>
        
        

    </div>
    
</footer>







<div id="copyright">
    <div class="container">
        <div class="col-md-12">
            
            <p class="pull-left">Copyright ©️ 2020, ServiceMesher all rights reserved.</p>
            
            
            <p class="pull-left">&nbsp;<a href="http://www.beian.miit.gov.cn/"> 苏ICP备20005919号</a></p>
            
            <p class="pull-right">
                模板来自 <a href="https://bootstrapious.com/p/universal-business-e-commerce-template">Bootstrapious</a>.
                

                移植到 Hugo 来自 <a href="https://github.com/devcows/hugo-universal-theme">DevCows</a>.
            </p>
        </div>
    </div>
</div>





    </div>
    

    <script src="//code.jquery.com/jquery-3.1.1.min.js" integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8=" crossorigin="anonymous"></script>
<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>

<script src="//cdnjs.cloudflare.com/ajax/libs/jquery-cookie/1.4.1/jquery.cookie.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/waypoints/4.0.1/jquery.waypoints.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/Counter-Up/1.0/jquery.counterup.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/jquery-parallax/1.1.3/jquery-parallax.js"></script>
<script src="/js/front.js"></script>


<script src="/js/owl.carousel.min.js"></script>

<script src="/js/prism.js"></script>


<script src="/js/algoliasearch.min.js"></script>
<script src="/js/autocomplete.min.js"></script>


  </body>
</html>
