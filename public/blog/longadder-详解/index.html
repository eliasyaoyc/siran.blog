<!DOCTYPE html>
<html lang="zh">

  <head>
  <meta charset="utf-8">
  <meta name="robots" content="all,follow">
  <meta name="googlebot" content="index,follow,snippet,archive">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>LongAdder 详解 · 技术分享</title>
  <meta name="author" content="Siran Yao(姚毅晨)" />

  
  <meta name="keywords" content="原子类, Jdk源码, 基础">
  

  <meta name="generator" content="Hugo 0.65.2" />

  
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">

  
  <link href="/css/animate.css" rel="stylesheet">

  
  
  <link href="/css/style.blue.css" rel="stylesheet" id="theme-stylesheet">
  

  
  <link href="/css/custom.css" rel="stylesheet">
  <link rel="stylesheet" href="/css/search.css" />

  
  
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
        <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  

  
  <link rel="shortcut icon" href="/img/123.png" type="image/x-icon" />
  <link rel="apple-touch-icon" href="/img/123.png" />

  
  <link href="/css/owl.carousel.css" rel="stylesheet">
  <link href="/css/owl.theme.css" rel="stylesheet">
  <link rel="alternate" href="/index.xml" type="application/rss+xml" title="Siran Yao">

  
  <link rel="stylesheet" href="/css/prism.css" />

  
  <meta property="og:title" content="LongAdder 详解" />
  <meta property="og:type" content="website" />
  <meta property="og:url" content="/blog/longadder-%E8%AF%A6%E8%A7%A3//" />
  <meta property="og:image" content="/img/uugai.com_1583215700293.png" />
  <meta property="og:image:alt" content="ServiceMesher Logo" />

  
  <meta name="description" content="LongAdder 类是jdk1.8新增的原子类，在多线程环境下，它的性能比普通的Atomic类性能高很多，继承 Striped64，通过Striped64的Cell来实现功能，并且在ConcurrentHashMap中也用了Striped64的Cell。">
  <meta property="og:description" content="LongAdder 类是jdk1.8新增的原子类，在多线程环境下，它的性能比普通的Atomic类性能高很多，继承 Striped64，通过Striped64的Cell来实现功能，并且在ConcurrentHashMap中也用了Striped64的Cell。">
  <meta name="twitter:description" content="LongAdder 类是jdk1.8新增的原子类，在多线程环境下，它的性能比普通的Atomic类性能高很多，继承 Striped64，通过Striped64的Cell来实现功能，并且在ConcurrentHashMap中也用了Striped64的Cell。">
  <meta property="og:description" content="LongAdder 类是jdk1.8新增的原子类，在多线程环境下，它的性能比普通的Atomic类性能高很多，继承 Striped64，通过Striped64的Cell来实现功能，并且在ConcurrentHashMap中也用了Striped64的Cell。" />

  
  <meta name="referrer" content="never">

  
  
  <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?154337f0d95f0b110f98c1d5d7038895";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
  </script>


  
  

</head>


  <body>
  <link href="https://cdn.bootcss.com/highlight.js/9.12.0/styles/monokai.min.css" rel="stylesheet">
  <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
    <div id="all">

        <header>

          <div class="navbar-affixed-top" data-spy="affix" data-offset-top="200">

    <div class="navbar navbar-default yamm" role="navigation" id="navbar">

        <div class="container">
            <div class="navbar-header">
                <a class="navbar-brand home" href="/">
                    <img src="/img/uugai.com_1583215700293.png" alt="LongAdder 详解 logo" class="hidden-xs hidden-sm">
                    <img src="/img/uugai.com_1583215700293.png" alt="LongAdder 详解 logo" class="visible-xs visible-sm">
                    <span class="sr-only">LongAdder 详解 - 跳到主页</span>
                </a>
                <div class="navbar-buttons">
                    <button type="button" class="navbar-toggle btn-template-main" data-toggle="collapse" data-target="#navigation">
                      <span class="sr-only">切换导航</span>
                        <i class="fa fa-align-justify"></i>
                    </button>
                </div>
            </div>
            

            <div class="navbar-collapse collapse" id="navigation">
                <ul class="nav navbar-nav navbar-right">
                  
                  <li class="dropdown">
                    
                    <a href="/">主页</a>
                    
                  </li>
                  
                  <li class="dropdown">
                    
                    <a href="/blog/">博客</a>
                    
                  </li>
                  
                  <li class="dropdown">
                    
                      <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">文档 <span class="caret"></span></a>
                    <ul class="dropdown-menu">
                      
                        <li><a href="https://istio.io/">Istio官网</a></li>
                      
                        <li><a href="http://pulsar.apache.org/en/">Pulsar官网</a></li>
                      
                    </ul>
                    
                  </li>
                  
                  <li class="dropdown">
                    
                    <a href="/contact/">联系我</a>
                    
                  </li>
                  
                  
                    <li>
                        <a href="#modalSearch" data-toggle="modal" data-target="#modalSearch" style="outline: none;">
                        <span class="hidden-sm hidden-md hidden-lg">搜索</span> <span id="searchGlyph" class="glyphicon glyphicon-search"></span>
                    </a>
                    </li>
                  
                </ul>
            </div>
            

        </div>
    </div>
    

</div>




<div id="modalSearch" class="modal fade" role="dialog">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <button type="button" class="close" data-dismiss="modal">&times;</button>
        <h4 class="modal-title">博客搜索</h4>
      </div>
      <div class="modal-body">
          
<div class="aa-input-container" id="aa-input-container">
    <input type="search" id="aa-search-input" class="aa-input-search" placeholder="输入文章标题或摘要" name="search" autocomplete="off" autofocus="autofocus"/>
    <svg class="aa-input-icon" viewBox="654 -372 1664 1664">
        <path d="M1806,332c0-123.3-43.8-228.8-131.5-316.5C1586.8-72.2,1481.3-116,1358-116s-228.8,43.8-316.5,131.5  C953.8,103.2,910,208.7,910,332s43.8,228.8,131.5,316.5C1129.2,736.2,1234.7,780,1358,780s228.8-43.8,316.5-131.5  C1762.2,560.8,1806,455.3,1806,332z M2318,1164c0,34.7-12.7,64.7-38,90s-55.3,38-90,38c-36,0-66-12.7-90-38l-343-342  c-119.3,82.7-252.3,124-399,124c-95.3,0-186.5-18.5-273.5-55.5s-162-87-225-150s-113-138-150-225S654,427.3,654,332  s18.5-186.5,55.5-273.5s87-162,150-225s138-113,225-150S1262.7-372,1358-372s186.5,18.5,273.5,55.5s162,87,225,150s113,138,150,225  S2062,236.7,2062,332c0,146.7-41.3,279.7-124,399l343,343C2305.7,1098.7,2318,1128.7,2318,1164z" />
    </svg>
</div>
<script src="/js/algoliasearch.min.js"></script>
<script src="/js/autocomplete.min.js"></script>

<script>
var client = algoliasearch("X4YB3WOBNV", "d2134c5a8d250e6d3246594240c45201");
var index = client.initIndex("servicemesher");

autocomplete('#aa-search-input',
{ hint: false}, {
    source: autocomplete.sources.hits(index, {hitsPerPage: 5}),
    
    displayKey: 'name',
    
    templates: {
        
        suggestion: function(suggestion) {
            baseURL=""
            baseURL=baseURL.substring(0,baseURL.length-1)
            return '<span>' + '<a href="' + baseURL + suggestion.url+ '">' +
                suggestion._highlightResult.title.value + '</a></span>'+
                '<span>'+suggestion._highlightResult.summary.value+'</span>';
        }
    }
});
</script>

      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-default" data-dismiss="modal">关闭</button>
      </div>
    </div>
  </div>
</div>


        </header>

        <div id="heading-breadcrumbs">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <h1>LongAdder 详解</h1>
            </div>
        </div>
    </div>
</div>


        <div id="content">
            <div class="container">

                <div class="row">

                    

                    <div class="col-md-9" id="blog-post">
                        <div class="well">
                            <div class="author-category">
                            <i class="fa fa-calendar-o">
                            2020年3月5日
                            </i>
                            |
                            
                            作者 Siran
                            
                            
                            
                            |
                            3800字 | 阅读大约需要8分钟
                            </div>
                            
                            
                            <div class="author-category">
                            
                            
                            归档于 <a href="/categories/%e5%8e%9f%e5%ad%90%e7%b1%bb">原子类</a>
                            
                            |
                            
                            
                            
                            标签
                            
                            <a style="text-transform:capitalize" href="/tags/%E5%8E%9F%E5%AD%90%E7%B1%BB/"><i>#原子类</i></a>
                            
                            </div>
                            
                            
                        </div>
                        <div id="post-content">
                          <h3 id="问题">问题</h3>
<ol>
<li>LongAdder 的实现原理？</li>
<li>LongAdder 与 AtomicLong 差别？</li>
<li>LongAdder 是强一致性还是最终一致性的？</li>
<li>LongAdder 中的Cell 数组是无限制扩容的吗？</li>
<li>LongAdder 是如何消除伪共享的？</li>
</ol>
<hr>
<h3 id="简介">简介</h3>
<blockquote>
<p>LongAdder 类是jdk1.8新增的原子类，在多线程环境下，它的性能比普通的Atomic类性能高很多，
继承 Striped64，通过Striped64的Cell来实现功能，并且在ConcurrentHashMap中也用了Striped64的Cell。</p>
</blockquote>
<hr>
<h3 id="源码分析">源码分析</h3>
<h4 id="实现原理">实现原理</h4>
<blockquote>
<p>在初始无竞争时，只更新base的值，当有多线程竞争时通过<code>分段的思想</code>，让不同的线程更新不同的段，最后把这些段相加(sum)就得到了完整的LongAdder存储的值，最终一致性。</p>
</blockquote>
<p><img src="/img/blog/%E5%8E%9F%E5%AD%90%E7%B1%BB/LongAdder.png" alt=""></p>
<hr>
<h4 id="内部类">内部类</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">// Striped64中的内部类，使用@sun.misc.Contended注解，说明里面的值消除伪共享。 
</span><span style="color:#75715e"></span><span style="color:#960050;background-color:#1e0010">@</span>sun.misc.Contended <span style="color:#66d9ef">static</span> final class Cell {
        <span style="color:#75715e">//每个cell中的值，在LongAdder中就是每次添加的值。使用volatile 来确保内存可见
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">volatile</span> <span style="color:#66d9ef">long</span> value;
        <span style="color:#75715e">//构造器
</span><span style="color:#75715e"></span>        Cell(<span style="color:#66d9ef">long</span> x) { value <span style="color:#f92672">=</span> x; }
        <span style="color:#75715e">//cas修改value的值
</span><span style="color:#75715e"></span>        final boolean cas(<span style="color:#66d9ef">long</span> cmp, <span style="color:#66d9ef">long</span> val) {
            <span style="color:#66d9ef">return</span> UNSAFE.compareAndSwapLong(this, valueOffset, cmp, val);
        }

        <span style="color:#75715e">// Unsafe 实力 在静态代码块中实例化
</span><span style="color:#75715e"></span>        private <span style="color:#66d9ef">static</span> final sun.misc.Unsafe UNSAFE;
        private <span style="color:#66d9ef">static</span> final <span style="color:#66d9ef">long</span> valueOffset;
        <span style="color:#66d9ef">static</span> {
            try {
                UNSAFE <span style="color:#f92672">=</span> sun.misc.Unsafe.getUnsafe();
                Class<span style="color:#f92672">&lt;?&gt;</span> ak <span style="color:#f92672">=</span> Cell.class;
                valueOffset <span style="color:#f92672">=</span> UNSAFE.objectFieldOffset
                    (ak.getDeclaredField(<span style="color:#e6db74">&#34;value&#34;</span>));
            } catch (Exception e) {
                throw new Error(e);
            }
        }
    }
</code></pre></div><hr>
<h4 id="主要属性">主要属性</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">    <span style="color:#75715e">//这些属性都是在Striped64中的
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//CPU数
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">static</span> final <span style="color:#66d9ef">int</span> NCPU <span style="color:#f92672">=</span> Runtime.getRuntime().availableProcessors();
    <span style="color:#75715e">//cells数组，存储各个段的值，Cell的数组长度最大是CPU * 2 在下面的#longAccumulate方法中会有体现
</span><span style="color:#75715e"></span>    transient <span style="color:#66d9ef">volatile</span> Cell[] cells;
    <span style="color:#75715e">//初始值，如果没有线程修改的话，就会直接通过CAS来修改这个值，不会创建cell
</span><span style="color:#75715e"></span>    transient <span style="color:#66d9ef">volatile</span> <span style="color:#66d9ef">long</span> base;
    <span style="color:#75715e">//标记是否有线程在扩容或者创建Cell，会通过cas来更新该值
</span><span style="color:#75715e"></span>    transient <span style="color:#66d9ef">volatile</span> <span style="color:#66d9ef">int</span> cellsBusy;
</code></pre></div><hr>
<h4 id="add-方法">add() 方法</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">public <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add</span>(<span style="color:#66d9ef">long</span> x) {
        Cell[] as; <span style="color:#75715e">//as 是 Striped64中的cells属性 存储各个段的值
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">long</span> b, v; <span style="color:#75715e">//b是Striped64中的base属性 最初的base属性，还没发生竞争; v是当前线程hash到的Cell中存储的值
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> m; <span style="color:#75715e">//m是cells的长度减1，hash时作为掩码使用
</span><span style="color:#75715e"></span>        Cell a; <span style="color:#75715e">//a是当前线程hash到的Cell
</span><span style="color:#75715e"></span>
        <span style="color:#75715e">//条件1： cells不为空说明已经出现过竞争了，cells已经创建了
</span><span style="color:#75715e"></span>        <span style="color:#75715e">//条件2： cas修改base值 失败，说明已经被其他线程改过了，出现竞争
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> ((as <span style="color:#f92672">=</span> cells) <span style="color:#f92672">!=</span> null <span style="color:#f92672">||</span> <span style="color:#f92672">!</span>casBase(b <span style="color:#f92672">=</span> base, b <span style="color:#f92672">+</span> x)) {
            <span style="color:#75715e">//true表示当前竞争还不激烈; false表示竞争激烈，多个线程hash到同一个Cell，可能要扩容
</span><span style="color:#75715e"></span>            boolean uncontended <span style="color:#f92672">=</span> true;
            <span style="color:#75715e">//条件1：cells为空，说明正在出现竞争，上面是从条件2过来的
</span><span style="color:#75715e"></span>            <span style="color:#75715e">//条件2：从上面的条件2过来，正在出现竞争，还没有创建cell放入数组，所以这个时候会满足此条件
</span><span style="color:#75715e"></span>            <span style="color:#75715e">//条件3：当前线程所在的Cell为空，说明当前线程还没有更新过Cell，应初始化一个Cell
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// 条件4：更新当前线程所在的Cell失败，说明现在竞争很激烈，多个线程hash到了同一个Cell，应扩容
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (as <span style="color:#f92672">==</span> null <span style="color:#f92672">||</span> (m <span style="color:#f92672">=</span> as.length <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span>
                    <span style="color:#75715e">// getProbe()方法返回的是线程中的threadLocalRandomProbe字段
</span><span style="color:#75715e"></span>                    <span style="color:#75715e">// 它是通过随机数生成的一个值，对于一个确定的线程这个值是固定的
</span><span style="color:#75715e"></span>                    <span style="color:#75715e">// 除非刻意修改它
</span><span style="color:#75715e"></span>                    (a <span style="color:#f92672">=</span> as[getProbe() <span style="color:#f92672">&amp;</span> m]) <span style="color:#f92672">==</span> null <span style="color:#f92672">||</span>
                    <span style="color:#f92672">!</span>(uncontended <span style="color:#f92672">=</span> a.cas(v <span style="color:#f92672">=</span> a.value, v <span style="color:#f92672">+</span> x)))
                <span style="color:#75715e">// 调用Striped64中的方法处理
</span><span style="color:#75715e"></span>                longAccumulate(x, null, uncontended);
        }
    }
</code></pre></div><ol>
<li>最初无竞争时只更新base</li>
<li>直到更新base失败时就是出现了竞争，创建cells数组</li>
<li>当多个线程竞争同一个Cell比较激烈时，可能要扩容</li>
</ol>
<hr>
<h4 id="longaccumulate-方法">longAccumulate 方法</h4>
<p>只有当在上面的#add方法出现了竞争，需要创建或者扩容cell的时候才会调用此方法</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">final <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">longAccumulate</span>(<span style="color:#66d9ef">long</span> x, LongBinaryOperator fn,
                              boolean wasUncontended) {
        <span style="color:#66d9ef">int</span> h;
        <span style="color:#75715e">//&lt;1&gt; 获取存储线程的probe值，会通过#ThreadLocalRandom.current()方法随机生成一个，之后就不会改变除非自己手动去修改
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> ((h <span style="color:#f92672">=</span> getProbe()) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
            <span style="color:#75715e">//如果没有初始化，那么进行初始化
</span><span style="color:#75715e"></span>            ThreadLocalRandom.current(); <span style="color:#75715e">// force initialization
</span><span style="color:#75715e"></span>            h <span style="color:#f92672">=</span> getProbe();
            <span style="color:#75715e">// 还没初始化，说明竞争的不激烈
</span><span style="color:#75715e"></span>            wasUncontended <span style="color:#f92672">=</span> true;
        }
        <span style="color:#75715e">//是否出现碰撞
</span><span style="color:#75715e"></span>        boolean collide <span style="color:#f92672">=</span> false;                <span style="color:#75715e">// True if last slot nonempty
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (;;) {
            Cell[] as; Cell a; <span style="color:#66d9ef">int</span> n; <span style="color:#66d9ef">long</span> v;
            <span style="color:#75715e">//&lt;2&gt; 如果Cells数组已经初始化
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> ((as <span style="color:#f92672">=</span> cells) <span style="color:#f92672">!=</span> null <span style="color:#f92672">&amp;&amp;</span> (n <span style="color:#f92672">=</span> as.length) <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
                <span style="color:#75715e">//&lt;2.1&gt; 当前线程进行hash获取在Cells数组中的值，判断是否为空，如果为空的话，进行初始化当前线程的cell然后塞入Cells数组中
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> ((a <span style="color:#f92672">=</span> as[(n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">&amp;</span> h]) <span style="color:#f92672">==</span> null) {
                    <span style="color:#75715e">//判断是否有竞争，其他线程在创建或者扩容Cells
</span><span style="color:#75715e"></span>                    <span style="color:#66d9ef">if</span> (cellsBusy <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {       <span style="color:#75715e">// Try to attach new Cell
</span><span style="color:#75715e"></span>                        <span style="color:#75715e">//创建cell
</span><span style="color:#75715e"></span>                        Cell r <span style="color:#f92672">=</span> new Cell(x);   <span style="color:#75715e">// Optimistically create
</span><span style="color:#75715e"></span>                        <span style="color:#75715e">//再次判断cellsBusy的值，并且cas的修改 意味着获取锁
</span><span style="color:#75715e"></span>                        <span style="color:#66d9ef">if</span> (cellsBusy <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> casCellsBusy()) {
                            <span style="color:#75715e">//标记是否创建成功
</span><span style="color:#75715e"></span>                            boolean created <span style="color:#f92672">=</span> false;
                            try {               <span style="color:#75715e">// Recheck under lock
</span><span style="color:#75715e"></span>                                Cell[] rs; <span style="color:#66d9ef">int</span> m, j;
                                <span style="color:#75715e">//重新获取Cells数组，找到当前线程hash到Cells数组中的位置。如果为null的话，则加入Cells数组中，create标记为true
</span><span style="color:#75715e"></span>                                <span style="color:#75715e">//note : 这里重新获取Cells数组的原因是因为可能有其他线程已经扩容了或者修改了里面的值
</span><span style="color:#75715e"></span>                                <span style="color:#66d9ef">if</span> ((rs <span style="color:#f92672">=</span> cells) <span style="color:#f92672">!=</span> null <span style="color:#f92672">&amp;&amp;</span>
                                    (m <span style="color:#f92672">=</span> rs.length) <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span>
                                    rs[j <span style="color:#f92672">=</span> (m <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">&amp;</span> h] <span style="color:#f92672">==</span> null) {
                                    rs[j] <span style="color:#f92672">=</span> r;
                                    created <span style="color:#f92672">=</span> true;
                                }
                            } finally {
                                <span style="color:#75715e">//释放锁
</span><span style="color:#75715e"></span>                                cellsBusy <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
                            }
                            <span style="color:#75715e">//创建成功直接返回
</span><span style="color:#75715e"></span>                            <span style="color:#66d9ef">if</span> (created)
                                <span style="color:#66d9ef">break</span>;
                            <span style="color:#66d9ef">continue</span>;           <span style="color:#75715e">// Slot is now non-empty
</span><span style="color:#75715e"></span>                        }
                    }
                    <span style="color:#75715e">//标记没有发生冲突
</span><span style="color:#75715e"></span>                    collide <span style="color:#f92672">=</span> false;
                }
                <span style="color:#75715e">// 这里对应了&lt;2.1&gt; 如果当前线程hash到Cells数组的位置不为null，并且wasUncontended的值为false 出现了竞争。则更新失败，继续自旋
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>wasUncontended)       <span style="color:#75715e">// CAS already known to fail
</span><span style="color:#75715e"></span>                    wasUncontended <span style="color:#f92672">=</span> true;      <span style="color:#75715e">// Continue after rehash
</span><span style="color:#75715e"></span>                <span style="color:#75715e">// 上面的else if 中如果wasUncontended为true 则没有出现竞争，尝试修改当前线程所在的cell的值，成功直接返回
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (a.cas(v <span style="color:#f92672">=</span> a.value, ((fn <span style="color:#f92672">==</span> null) <span style="color:#f92672">?</span> v <span style="color:#f92672">+</span> x :
                                             fn.applyAsLong(v, x))))
                    <span style="color:#66d9ef">break</span>;
                <span style="color:#75715e">// 查看是否要进行扩容，因为每次扩容是 * 2 所以当到了cpu的核数就不会在扩容了
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (n <span style="color:#f92672">&gt;=</span> NCPU <span style="color:#f92672">||</span> cells <span style="color:#f92672">!=</span> as)
                    collide <span style="color:#f92672">=</span> false;            <span style="color:#75715e">// At max size or stale
</span><span style="color:#75715e"></span>                <span style="color:#75715e">//如果上上个elseif 修改cell的值失败了 且上个条件不成立  出现了冲突，collide值改为true
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>collide)
                    collide <span style="color:#f92672">=</span> true;
                <span style="color:#75715e">// 到这里就说明已经出现了冲突了，尝试获取占有锁，并且扩容
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (cellsBusy <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> casCellsBusy()) {
                    try {
                        <span style="color:#75715e">//检查是否有其它线程已经扩容过了
</span><span style="color:#75715e"></span>                        <span style="color:#66d9ef">if</span> (cells <span style="color:#f92672">==</span> as) {      <span style="color:#75715e">// Expand table unless stale
</span><span style="color:#75715e"></span>                            <span style="color:#75715e">//扩大2倍 旧数组拷贝到新数组中，重新赋值
</span><span style="color:#75715e"></span>                            Cell[] rs <span style="color:#f92672">=</span> new Cell[n <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">1</span>];
                            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; <span style="color:#f92672">++</span>i)
                                rs[i] <span style="color:#f92672">=</span> as[i];
                            cells <span style="color:#f92672">=</span> rs;
                        }
                    } finally {
                        <span style="color:#75715e">//释放锁
</span><span style="color:#75715e"></span>                        cellsBusy <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
                    }
                    <span style="color:#75715e">//解决了冲突，继续尝试
</span><span style="color:#75715e"></span>                    collide <span style="color:#f92672">=</span> false;
                    <span style="color:#66d9ef">continue</span>;                   <span style="color:#75715e">// Retry with expanded table
</span><span style="color:#75715e"></span>                }
                <span style="color:#75715e">//更新失败或者达到了CPU核心数，重新生成probe，并重试
</span><span style="color:#75715e"></span>                h <span style="color:#f92672">=</span> advanceProbe(h);
            }

            <span style="color:#75715e">//&lt;3&gt; 对应&lt;2&gt; Cell数组还没初始化，cas修改cellsBusy的值，相当于是一个独占锁
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (cellsBusy <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> cells <span style="color:#f92672">==</span> as <span style="color:#f92672">&amp;&amp;</span> casCellsBusy()) {
                <span style="color:#75715e">//初始化是否成功
</span><span style="color:#75715e"></span>                boolean init <span style="color:#f92672">=</span> false;
                try {                           <span style="color:#75715e">// Initialize table
</span><span style="color:#75715e"></span>                    <span style="color:#75715e">//检测是否有其它线程初始化过
</span><span style="color:#75715e"></span>                    <span style="color:#66d9ef">if</span> (cells <span style="color:#f92672">==</span> as) {
                        <span style="color:#75715e">//初始容量为2
</span><span style="color:#75715e"></span>                        Cell[] rs <span style="color:#f92672">=</span> new Cell[<span style="color:#ae81ff">2</span>];
                        <span style="color:#75715e">//当前线程会进行hash然后放置到cell数组中
</span><span style="color:#75715e"></span>                        rs[h <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> new Cell(x);
                        cells <span style="color:#f92672">=</span> rs;
                        init <span style="color:#f92672">=</span> true;
                    }
                } finally {
                    <span style="color:#75715e">//释放锁
</span><span style="color:#75715e"></span>                    cellsBusy <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
                }
                <span style="color:#75715e">// 初始化成功直接返回
</span><span style="color:#75715e"></span>                <span style="color:#75715e">// 因为增加的值已经同时创建到Cell中了
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> (init)
                    <span style="color:#66d9ef">break</span>;
            }

            <span style="color:#75715e">//&lt;4&gt; 对应&lt;3&gt; 已经有线程在初始化Cell数组了 也就是&lt;3&gt;中的cellsBusy = 1，那么尝试cas更新base。如果成功直接返回
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (casBase(v <span style="color:#f92672">=</span> base, ((fn <span style="color:#f92672">==</span> null) <span style="color:#f92672">?</span> v <span style="color:#f92672">+</span> x :
                                        fn.applyAsLong(v, x))))
                <span style="color:#66d9ef">break</span>;                          <span style="color:#75715e">// Fall back on using base
</span><span style="color:#75715e"></span>        }
    }
</code></pre></div><p><strong>总结一下：</strong></p>
<ol>
<li>如果Cells数组未初始化，当前线程会尝试占有cellsBusy锁并创建cells数组；</li>
<li>如果当前线程尝试创建Cells数组时，发现有其它线程已经在创建了，就尝试更新base，如果成功就返回；</li>
<li>通过线程的probe值找到当前线程应该更新Cells数组中的哪个Cell；</li>
<li>如果当前线程所在的Cell未初始化，就尝试占有cellsBusy锁并在相应的位置创建一个Cell；</li>
<li>尝试CAS更新当前线程所在的Cell，如果成功就返回，如果失败说明出现冲突；</li>
<li>当前线程更新Cell失败后并不是立即扩容，而是尝试更新probe值后再重试一次；</li>
<li>如果在重试的时候还是更新失败，就扩容；</li>
<li>扩容时当前线程占有cellsBusy锁，并把数组容量扩大到两倍，再迁移原cells数组中元素到新数组中；</li>
<li>cellsBusy在创建Cells数组、创建Cell、扩容Cells数组三个地方用到；</li>
</ol>
<hr>
<h4 id="sum-方法">sum 方法</h4>
<p>获取LongAdder中真正存储的值的大小，通过把base和所有段相加得到。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">public <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">sum</span>() {
        Cell[] as <span style="color:#f92672">=</span> cells;
        Cell a;
        <span style="color:#75715e">//&lt;1&gt; sum初始等于base
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">long</span> sum <span style="color:#f92672">=</span> base;
        <span style="color:#75715e">//&lt;2&gt; 如果Cells不为空
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (as <span style="color:#f92672">!=</span> null) {
            <span style="color:#75715e">//遍历所有的Cell
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> as.length; <span style="color:#f92672">++</span>i) {
                <span style="color:#75715e">//如果所在的Cell不为空，就把它的value累加到sum中
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> ((a <span style="color:#f92672">=</span> as[i]) <span style="color:#f92672">!=</span> null)
                    sum <span style="color:#f92672">+=</span> a.value;
            }
        }
        <span style="color:#75715e">//返回sum
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> sum;
    }
</code></pre></div><p><code>note：</code>如果前面已经累加到sum上的Cell的value有修改，没法计算到了。所以说LongAdder是最终一致性</p>
<hr>
<h4 id="longadder-vs-atomiclong">LongAdder VS AtomicLong</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">public class LongAddrVSAtomicLongTest {
    public <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> main(String[] args) {
        testAtomicLongVSLongAdder(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">10000000</span>);
        testAtomicLongVSLongAdder(<span style="color:#ae81ff">10</span>,<span style="color:#ae81ff">10000000</span>);
        testAtomicLongVSLongAdder(<span style="color:#ae81ff">20</span>,<span style="color:#ae81ff">10000000</span>);
        testAtomicLongVSLongAdder(<span style="color:#ae81ff">40</span>,<span style="color:#ae81ff">10000000</span>);
        testAtomicLongVSLongAdder(<span style="color:#ae81ff">80</span>,<span style="color:#ae81ff">10000000</span>);
    }
    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> testAtomicLongVSLongAdder(final <span style="color:#66d9ef">int</span> threadCount,final <span style="color:#66d9ef">int</span> times){
        try {
            System.out.println(<span style="color:#e6db74">&#34;threadCount: &#34;</span> <span style="color:#f92672">+</span> threadCount <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;,times: &#34;</span> <span style="color:#f92672">+</span> times);
            <span style="color:#66d9ef">long</span> start <span style="color:#f92672">=</span> System.currentTimeMillis();
            testLongAdder(threadCount,times);
            System.out.println(<span style="color:#e6db74">&#34;LongAdder elapse: &#34;</span> <span style="color:#f92672">+</span> (System.currentTimeMillis() <span style="color:#f92672">-</span> start) <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;ms&#34;</span>);
            <span style="color:#66d9ef">long</span> start2 <span style="color:#f92672">=</span> System.currentTimeMillis();
            testAtomicLong(threadCount,times);
            System.out.println(<span style="color:#e6db74">&#34;Atomic elapse: &#34;</span> <span style="color:#f92672">+</span> (System.currentTimeMillis() <span style="color:#f92672">-</span> start2) <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;ms&#34;</span>);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> testLongAdder(final <span style="color:#66d9ef">int</span> threadCount,final <span style="color:#66d9ef">int</span> times) throws InterruptedException {
        LongAdder longAdder <span style="color:#f92672">=</span> new LongAdder();
        List<span style="color:#f92672">&lt;</span>Thread<span style="color:#f92672">&gt;</span> list <span style="color:#f92672">=</span> new ArrayList<span style="color:#f92672">&lt;&gt;</span>();
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> threadCount; i<span style="color:#f92672">++</span>) {
            list.add(new Thread(()<span style="color:#f92672">-&gt;</span>{
                <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> times; j<span style="color:#f92672">++</span>) {
                    longAdder.add(<span style="color:#ae81ff">1</span>);
                }
            }));
        }
        <span style="color:#66d9ef">for</span> (Thread <span style="color:#66d9ef">thread</span> <span style="color:#f92672">:</span> list) {
            <span style="color:#66d9ef">thread</span>.start();
        }
        <span style="color:#66d9ef">for</span> (Thread <span style="color:#66d9ef">thread</span> <span style="color:#f92672">:</span> list) {
            <span style="color:#66d9ef">thread</span>.join();;
        }
    }

    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> testAtomicLong(final <span style="color:#66d9ef">int</span> threadCount,final <span style="color:#66d9ef">int</span> times) throws InterruptedException {
        AtomicLong atomicLong <span style="color:#f92672">=</span> new AtomicLong();
        List<span style="color:#f92672">&lt;</span>Thread<span style="color:#f92672">&gt;</span> list <span style="color:#f92672">=</span> new ArrayList<span style="color:#f92672">&lt;&gt;</span>();
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> threadCount; i<span style="color:#f92672">++</span>) {
            list.add((new Thread(()<span style="color:#f92672">-&gt;</span>{
                <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> times; j<span style="color:#f92672">++</span>) {
                    atomicLong.incrementAndGet();
                }
            })));
        }
        <span style="color:#66d9ef">for</span> (Thread <span style="color:#66d9ef">thread</span> <span style="color:#f92672">:</span> list) {
            <span style="color:#66d9ef">thread</span>.start();
        }
        <span style="color:#66d9ef">for</span> (Thread <span style="color:#66d9ef">thread</span> <span style="color:#f92672">:</span> list) {
            <span style="color:#66d9ef">thread</span>.join();
        }
    }

}
</code></pre></div><h4 id="结果">结果：</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">threadCount: <span style="color:#ae81ff">1</span>,times: <span style="color:#ae81ff">10000000</span>
LongAdder elapse: <span style="color:#ae81ff">219</span>ms
Atomic elapse: <span style="color:#ae81ff">72</span>ms
threadCount: <span style="color:#ae81ff">10</span>,times: <span style="color:#ae81ff">10000000</span>
LongAdder elapse: <span style="color:#ae81ff">232</span>ms
Atomic elapse: <span style="color:#ae81ff">1948</span>ms
threadCount: <span style="color:#ae81ff">20</span>,times: <span style="color:#ae81ff">10000000</span>
LongAdder elapse: <span style="color:#ae81ff">462</span>ms
Atomic elapse: <span style="color:#ae81ff">4113</span>ms
threadCount: <span style="color:#ae81ff">40</span>,times: <span style="color:#ae81ff">10000000</span>
LongAdder elapse: <span style="color:#ae81ff">952</span>ms
Atomic elapse: <span style="color:#ae81ff">9520</span>ms
threadCount: <span style="color:#ae81ff">80</span>,times: <span style="color:#ae81ff">10000000</span>
LongAdder elapse: <span style="color:#ae81ff">1508</span>ms
Atomic elapse: <span style="color:#ae81ff">21143</span>ms
</code></pre></div><blockquote>
<p>可以看到线程数越多，竞争越多的情况下，对LongAdder的性能没有太大的影响而AtomicInteger则越来越慢。</p>
</blockquote>
<hr>
<h3 id="总结">总结</h3>
<ol>
<li><strong>LongAdder通过base和cells数组来存储值，无竞争的时候直接cas的修改base的值，出现竞争创建cell使用分段的思想来提交性能</strong></li>
<li><strong>不同的线程会hash到不同的cell上去更新，减少了竞争</strong></li>
<li><strong>LongAdder中Cell的数组最大容量就是当前cpu数</strong></li>
<li><strong>LongAddr 是最终一致性的。</strong></li>
</ol>

                        </div>
                        
                        
                        
                        
                        <ul class="pager blog-pager">
                        
                        <li class="previous">
                        <a href="/blog/apache-pulsar-topic-discovery/" data-toggle="tooltip" data-placement="top" title="Apache Pulsar - Topic Discovery">&larr; 上一篇</a>
                        </li>
                         
                        <li class="next">
                        <a href="/blog/atomicstampedreference-%E8%AF%A6%E8%A7%A3/" data-toggle="tooltip" data-placement="top" title="AtomicStampedReference 详解">下一篇 &rarr;</a>
                        </li>
                        
                        </ul>
                        
                        
                        


                    </div>
                    

                    

                    

                    <div class="col-md-3">

                        

                        <div class="panel panel-default sidebar-menu">
     
    <div class="panel-heading">
     <h3 class="panel-title">相关文章</h3>
    </div>
    <div class="panel-body">
     <ul class="nav nav-pills nav-stacked">
        
        <li><a href="/blog/new-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F-builder/"><i class="fa fa-link"></i>new 对象的几种方式-Builder</a></li>
         
        <li><a href="/blog/condition-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><i class="fa fa-link"></i>Condition 源码分析</a></li>
         
        <li><a href="/blog/priorityqueue-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><i class="fa fa-link"></i>PriorityQueue 源码分析</a></li>
         
        <li><a href="/blog/countdownlatch-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><i class="fa fa-link"></i>CountDownLatch 源码分析</a></li>
         
        <li><a href="/blog/reentrantreadwritelock-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><i class="fa fa-link"></i>ReentrantReadWriteLock 源码分析</a></li>
         
     </ul>
    </div>
     
</div>





<div class="panel panel-default sidebar-menu">

    <div class="panel-heading">
      <h3 class="panel-title">分类</h3>
    </div>

    <div class="panel-body">
        <ul class="nav nav-pills nav-stacked">
            
            <li><a href="/categories/aqs"><i class="fa fa-navicon"></i>aqs (6)</a>
            </li>
            
            <li><a href="/categories/pulsar"><i class="fa fa-navicon"></i>pulsar (6)</a>
            </li>
            
            <li><a href="/categories/%e5%88%86%e5%b8%83%e5%bc%8f"><i class="fa fa-navicon"></i>分布式 (2)</a>
            </li>
            
            <li><a href="/categories/%e5%8e%9f%e5%ad%90%e7%b1%bb"><i class="fa fa-navicon"></i>原子类 (2)</a>
            </li>
            
            <li><a href="/categories/%e7%ba%bf%e7%a8%8b%e6%b1%a0"><i class="fa fa-navicon"></i>线程池 (3)</a>
            </li>
            
            <li><a href="/categories/%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f"><i class="fa fa-navicon"></i>设计模式 (1)</a>
            </li>
            
            <li><a href="/categories/%e9%9b%86%e5%90%88"><i class="fa fa-navicon"></i>集合 (1)</a>
            </li>
            
        </ul>
    </div>
</div>







                        

                    </div>
                    

                    

                </div>
                

            </div>
            
        </div>
        

        <footer id="footer">
    <div class="container">

        
        <div class="col-md-4 col-sm-6">
            <h4>关于我</h4>

            <p>Service Mesh 爱好者</p>

            <hr class="hidden-md hidden-lg hidden-sm">

        </div>
        
        

        <div class="col-md-4 col-sm-6">

             
            <h4>最新博客</h4>

            <div class="blog-entries">
                
                <div class="item same-height-row clearfix">
                    <div class="image same-height-always">
                        <a href="/blog/atomicstampedreference-%E8%AF%A6%E8%A7%A3/">
                            
                            <img src="/img/blog/banners/006tKfTcly1g0n3qqw0xqj31400u0hdt.jpg" class="img-responsive" alt="AtomicStampedReference 详解">
                            
                        </a>
                    </div>
                    <div class="name same-height-always">
                        <h5><a href="/blog/atomicstampedreference-%E8%AF%A6%E8%A7%A3/">AtomicStampedReference 详解</a></h5>
                    </div>
                </div>
                
                <div class="item same-height-row clearfix">
                    <div class="image same-height-always">
                        <a href="/blog/longadder-%E8%AF%A6%E8%A7%A3/">
                            
                            <img src="/img/blog/banners/006tKfTcly1g0d0qfcwpfj31400u0u11.jpg" class="img-responsive" alt="LongAdder 详解">
                            
                        </a>
                    </div>
                    <div class="name same-height-always">
                        <h5><a href="/blog/longadder-%E8%AF%A6%E8%A7%A3/">LongAdder 详解</a></h5>
                    </div>
                </div>
                
                <div class="item same-height-row clearfix">
                    <div class="image same-height-always">
                        <a href="/blog/apache-pulsar-topic-discovery/">
                            
                            <img src="/img/blog/pulsar/pulsar.svg" class="img-responsive" alt="Apache Pulsar - Topic Discovery">
                            
                        </a>
                    </div>
                    <div class="name same-height-always">
                        <h5><a href="/blog/apache-pulsar-topic-discovery/">Apache Pulsar - Topic Discovery</a></h5>
                    </div>
                </div>
                
            </div>

            <hr class="hidden-md hidden-lg">
             

        </div>
        

        
        <div class="col-md-4 col-sm-6 ">

            <h4>联系</h4>

            <p>个人微信</br>请备注姓名-公司信息</p><p><img src="/img/1.png"></p>
      

            <a href="/contact" class="btn btn-small btn-template-main">跳到联系页面</a>

            <hr class="hidden-md hidden-lg hidden-sm">

        </div>
        
        

    </div>
    
</footer>







<div id="copyright">
    <div class="container">
        <div class="col-md-12">
            
            <p class="pull-left">Copyright ©️ 2020, ServiceMesher all rights reserved.</p>
            
            
            <p class="pull-left">&nbsp;<a href="http://www.beian.miit.gov.cn/"> 苏ICP备20005919号</a></p>
            
            <p class="pull-right">
                模板来自 <a href="https://bootstrapious.com/p/universal-business-e-commerce-template">Bootstrapious</a>.
                

                移植到 Hugo 来自 <a href="https://github.com/devcows/hugo-universal-theme">DevCows</a>.
            </p>
        </div>
    </div>
</div>





    </div>
    

    <script src="//code.jquery.com/jquery-3.1.1.min.js" integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8=" crossorigin="anonymous"></script>
<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>

<script src="//cdnjs.cloudflare.com/ajax/libs/jquery-cookie/1.4.1/jquery.cookie.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/waypoints/4.0.1/jquery.waypoints.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/Counter-Up/1.0/jquery.counterup.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/jquery-parallax/1.1.3/jquery-parallax.js"></script>
<script src="/js/front.js"></script>


<script src="/js/owl.carousel.min.js"></script>

<script src="/js/prism.js"></script>


<script src="/js/algoliasearch.min.js"></script>
<script src="/js/autocomplete.min.js"></script>


  </body>
</html>
