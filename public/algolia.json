[{"author":"Siran","authorlink":null,"banner":"/img/blog/banners/006tKfTcly1g0n3qqw0xqj31400u0hdt.jpg","categories":["原子类"],"date":"2020-03-05T12:37:42+08:00","fuzzywordcount":1800,"keywords":["原子类","基础"],"lang":"zh","lastmod":"2020-03-05T12:37:42+08:00","objectID":"b7b06923bb1bba32c4ec77c19cd352c0","permalink":"/blog/atomicstampedreference-%E8%AF%A6%E8%A7%A3/","publishdate":"2020-03-05T12:37:42+08:00","readingtime":4,"relpermalink":"/blog/atomicstampedreference-%E8%AF%A6%E8%A7%A3/","summary":"AtomicStampedReference是jdk1.5出的一个类，用于解决其他原子类无法解决的ABA问题。","tags":["原子类"],"title":"AtomicStampedReference 详解","translator":null,"url":"/blog/atomicstampedreference-%E8%AF%A6%E8%A7%A3/","weight":0,"wordcount":1746},{"author":"Siran","authorlink":null,"banner":"/img/blog/banners/006tKfTcly1g0d0qfcwpfj31400u0u11.jpg","categories":["原子类"],"date":"2020-03-05T11:37:42+08:00","fuzzywordcount":3800,"keywords":["原子类","Jdk源码","基础"],"lang":"zh","lastmod":"2020-03-05T11:37:42+08:00","objectID":"5c9148b543f266a2c4c8b8ac4cbebac4","permalink":"/blog/longadder-%E8%AF%A6%E8%A7%A3/","publishdate":"2020-03-05T11:37:42+08:00","readingtime":8,"relpermalink":"/blog/longadder-%E8%AF%A6%E8%A7%A3/","summary":"LongAdder 类是jdk1.8新增的原子类，在多线程环境下，它的性能比普通的Atomic类性能高很多，继承 Striped64，通过Striped64的Cell来实现功能，并且在ConcurrentHashMap中也用了Striped64的Cell。","tags":["原子类"],"title":"LongAdder 详解","translator":null,"url":"/blog/longadder-%E8%AF%A6%E8%A7%A3/","weight":0,"wordcount":3752},{"author":"Siran","authorlink":null,"banner":"/img/blog/pulsar/pulsar.svg","categories":["Pulsar"],"date":"2020-03-04T22:37:42+08:00","fuzzywordcount":100,"keywords":["Pulsar"],"lang":"zh","lastmod":"2020-03-04T22:37:42+08:00","objectID":"1d3d4770a53b287b597c87ac1de65cd3","permalink":"/blog/apache-pulsar-topic-discovery/","publishdate":"2020-03-04T22:37:42+08:00","readingtime":1,"relpermalink":"/blog/apache-pulsar-topic-discovery/","summary":"","tags":["Pulsar"],"title":"Apache Pulsar - Topic Discovery","translator":null,"url":"/blog/apache-pulsar-topic-discovery/","weight":0,"wordcount":4},{"author":"Siran","authorlink":null,"banner":"/img/blog/banners/006tNc79ly1g1wrwnznblj31400u0x6p.jpg","categories":["设计模式"],"date":"2020-03-04T15:37:42+08:00","fuzzywordcount":100,"keywords":["设计模式","Jdk源码","基础"],"lang":"zh","lastmod":"2020-03-04T15:37:42+08:00","objectID":"01e3ca50bd7b06bae465feb59edba229","permalink":"/blog/new-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F-builder/","publishdate":"2020-03-04T15:37:42+08:00","readingtime":1,"relpermalink":"/blog/new-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F-builder/","summary":"","tags":["设计模式"],"title":"new 对象的几种方式-Builder","translator":null,"url":"/blog/new-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F-builder/","weight":0,"wordcount":4},{"author":"Siran","authorlink":null,"banner":"/img/blog/pulsar/pulsar.svg","categories":["Pulsar"],"date":"2020-03-04T13:37:42+08:00","fuzzywordcount":100,"keywords":["Pulsar"],"lang":"zh","lastmod":"2020-03-04T13:37:42+08:00","objectID":"80187514d7cf8b754df33141ee462a85","permalink":"/blog/apache-pulsar-%E7%9A%84%E8%B7%A8%E5%9C%B0%E5%9F%9F%E5%A4%8D%E5%88%B6%E6%9C%BA%E5%88%B6-geo-replication%E4%B8%80/","publishdate":"2020-03-04T13:37:42+08:00","readingtime":1,"relpermalink":"/blog/apache-pulsar-%E7%9A%84%E8%B7%A8%E5%9C%B0%E5%9F%9F%E5%A4%8D%E5%88%B6%E6%9C%BA%E5%88%B6-geo-replication%E4%B8%80/","summary":"","tags":["Pulsar"],"title":"Apache Pulsar 的跨地域复制机制 - Geo Replication(一)","translator":null,"url":"/blog/apache-pulsar-%E7%9A%84%E8%B7%A8%E5%9C%B0%E5%9F%9F%E5%A4%8D%E5%88%B6%E6%9C%BA%E5%88%B6-geo-replication%E4%B8%80/","weight":0,"wordcount":4},{"author":"Siran","authorlink":null,"banner":"/img/blog/pulsar/pulsar.svg","categories":["Pulsar"],"date":"2020-03-04T13:37:42+08:00","fuzzywordcount":100,"keywords":["Pulsar"],"lang":"zh","lastmod":"2020-03-04T13:37:42+08:00","objectID":"cb6f2b075b42aad1b0e9222457762f66","permalink":"/blog/apache-pulsar-%E7%9A%84%E8%B7%A8%E5%9C%B0%E5%9F%9F%E5%A4%8D%E5%88%B6%E6%9C%BA%E5%88%B6-geo-replication%E4%BA%8C/","publishdate":"2020-03-04T13:37:42+08:00","readingtime":1,"relpermalink":"/blog/apache-pulsar-%E7%9A%84%E8%B7%A8%E5%9C%B0%E5%9F%9F%E5%A4%8D%E5%88%B6%E6%9C%BA%E5%88%B6-geo-replication%E4%BA%8C/","summary":"","tags":["Pulsar"],"title":"Apache Pulsar 的跨地域复制机制 - Geo Replication(二)","translator":null,"url":"/blog/apache-pulsar-%E7%9A%84%E8%B7%A8%E5%9C%B0%E5%9F%9F%E5%A4%8D%E5%88%B6%E6%9C%BA%E5%88%B6-geo-replication%E4%BA%8C/","weight":0,"wordcount":4},{"author":"Siran","authorlink":null,"banner":"/img/blog/pulsar/pulsar.svg","categories":["Pulsar"],"date":"2020-03-04T13:37:42+08:00","fuzzywordcount":100,"keywords":["Pulsar"],"lang":"zh","lastmod":"2020-03-04T13:37:42+08:00","objectID":"e6957dae8c6e0c45ff5ebe607adfb524","permalink":"/blog/macos-%E5%8D%95%E6%9C%BA%E6%90%AD%E5%BB%BA-pulsar-%E9%9B%86%E7%BE%A4/","publishdate":"2020-03-04T13:37:42+08:00","readingtime":1,"relpermalink":"/blog/macos-%E5%8D%95%E6%9C%BA%E6%90%AD%E5%BB%BA-pulsar-%E9%9B%86%E7%BE%A4/","summary":"","tags":["Pulsar"],"title":"MacOS 单机搭建 Pulsar 集群","translator":null,"url":"/blog/macos-%E5%8D%95%E6%9C%BA%E6%90%AD%E5%BB%BA-pulsar-%E9%9B%86%E7%BE%A4/","weight":0,"wordcount":4},{"author":"Siran","authorlink":null,"banner":"/img/blog/pulsar/pulsar.svg","categories":["Pulsar"],"date":"2020-03-04T13:37:42+08:00","fuzzywordcount":100,"keywords":["Pulsar"],"lang":"zh","lastmod":"2020-03-04T13:37:42+08:00","objectID":"5a26915ce04432d7f2e44cd5cd6ae4c5","permalink":"/blog/pulsar-vs.-kafka1-%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E6%A8%A1%E5%9E%8B/","publishdate":"2020-03-04T13:37:42+08:00","readingtime":1,"relpermalink":"/blog/pulsar-vs.-kafka1-%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E6%A8%A1%E5%9E%8B/","summary":"","tags":["Pulsar"],"title":"Pulsar VS. Kafka（1）: 消息消费模型","translator":null,"url":"/blog/pulsar-vs.-kafka1-%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E6%A8%A1%E5%9E%8B/","weight":0,"wordcount":4},{"author":"Siran","authorlink":null,"banner":"/img/blog/pulsar/pulsar.svg","categories":["Pulsar"],"date":"2020-03-04T13:37:42+08:00","fuzzywordcount":100,"keywords":["Pulsar"],"lang":"zh","lastmod":"2020-03-04T13:37:42+08:00","objectID":"694552aef862d86d0413887aa10eb9cd","permalink":"/blog/pulsar-vs.-kafka2-%E4%BB%A5segment%E4%B8%BA%E4%B8%AD%E5%BF%83%E7%9A%84%E6%9E%B6%E6%9E%84/","publishdate":"2020-03-04T13:37:42+08:00","readingtime":1,"relpermalink":"/blog/pulsar-vs.-kafka2-%E4%BB%A5segment%E4%B8%BA%E4%B8%AD%E5%BF%83%E7%9A%84%E6%9E%B6%E6%9E%84/","summary":"","tags":["Pulsar"],"title":"Pulsar VS. Kafka（2）: 以Segment为中心的架构","translator":null,"url":"/blog/pulsar-vs.-kafka2-%E4%BB%A5segment%E4%B8%BA%E4%B8%AD%E5%BF%83%E7%9A%84%E6%9E%B6%E6%9E%84/","weight":0,"wordcount":4},{"author":"Siran","authorlink":null,"banner":"/img/blog/banners/6ce41a46gy1g31wxsf5ibj20rs0ku10r.jpg","categories":["AQS"],"date":"2020-03-01T19:12:42+08:00","fuzzywordcount":6000,"keywords":["AQS","Jdk源码","基础"],"lang":"zh","lastmod":"2020-03-01T19:12:42+08:00","objectID":"635f9e349fc84255990d88d55c9b22e4","permalink":"/blog/condition-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","publishdate":"2020-03-01T19:12:42+08:00","readingtime":12,"relpermalink":"/blog/condition-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","summary":"Condition可以替代传统的Object中的wait()、notify()和notifyAll()方法来实现线程间的通信，使线程间协作更加安全和高效。","tags":["AQS"],"title":"Condition 源码分析","translator":null,"url":"/blog/condition-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","weight":0,"wordcount":5924},{"author":"Siran","authorlink":null,"banner":"/img/blog/banners/006tNbRwly1fug0hms6vej31jk15ou0x.jpg","categories":["线程池"],"date":"2020-02-15T19:12:42+08:00","fuzzywordcount":3700,"keywords":["线程池","基础"],"lang":"zh","lastmod":"2020-02-15T19:12:42+08:00","objectID":"4746203e03ccd98294ded5be934c9b0f","permalink":"/blog/futuretask-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","publishdate":"2020-02-15T19:12:42+08:00","readingtime":8,"relpermalink":"/blog/futuretask-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","summary":"FutureTask 是一个可以取消的异步计算任务，实现Future，Runnable。提供超时控制、可以获取线程执行后的返回结果、可以取消。","tags":["线程池"],"title":"FutureTask 源码分析","translator":null,"url":"/blog/futuretask-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","weight":0,"wordcount":3616},{"author":"Siran","authorlink":null,"banner":"/img/blog/banners/00704eQkgy1fs2ua9kohvj30rs0kub29.jpg","categories":["分布式"],"date":"2020-02-13T19:12:42+08:00","fuzzywordcount":8000,"keywords":["分布式"],"lang":"zh","lastmod":"2020-02-13T19:12:42+08:00","objectID":"8e91c42cb312d92987e54d622d970054","permalink":"/blog/raft-%E5%8D%8F%E8%AE%AE/","publishdate":"2020-02-13T19:12:42+08:00","readingtime":16,"relpermalink":"/blog/raft-%E5%8D%8F%E8%AE%AE/","summary":"Raft 是一种为了管理复制日志的一致性算法。它提供了和 Paxos 算法相同的功能和性能，但是比 Paxos 更容易理解并且更容易实现。","tags":["分布式"],"title":"Raft 协议","translator":null,"url":"/blog/raft-%E5%8D%8F%E8%AE%AE/","weight":0,"wordcount":7982},{"author":"Siran","authorlink":null,"banner":"/img/blog/banners/00704eQkgy1fs3o6ljkknj30rs0ku4qp.jpg","categories":["集合"],"date":"2020-02-12T19:12:42+08:00","fuzzywordcount":2900,"keywords":["集合","Jdk源码","基础"],"lang":"zh","lastmod":"2020-02-12T19:12:42+08:00","objectID":"9febe5cdceb9c396156b27702ac47bb9","permalink":"/blog/priorityqueue-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","publishdate":"2020-02-12T19:12:42+08:00","readingtime":6,"relpermalink":"/blog/priorityqueue-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","summary":"PriorityQueue里的每个元素都会进行排序，每次弹出一个元素要么是最大的要么是最小的，取决于排序规则。","tags":["集合"],"title":"PriorityQueue 源码分析","translator":null,"url":"/blog/priorityqueue-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","weight":0,"wordcount":2812},{"author":"Siran","authorlink":null,"banner":"/img/blog/banners/006tKfTcgy1ftdx65tgduj30rs0kugov.jpg","categories":["AQS"],"date":"2020-02-05T19:12:42+08:00","fuzzywordcount":4600,"keywords":["AQS","Jdk源码","基础"],"lang":"zh","lastmod":"2020-02-05T19:12:42+08:00","objectID":"7cc723030aaf71daa866b09b2d9fc54e","permalink":"/blog/countdownlatch-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","publishdate":"2020-02-05T19:12:42+08:00","readingtime":10,"relpermalink":"/blog/countdownlatch-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","summary":"CountDownLatch是通过一个计数器来实现的，计数器的初始值为线程的数量。每当一个线程完成了自己的任务后，计数器的值就会减1。当计数器值到达0时，它表示所有的线程已经完成了任务，然后在闭锁上等待的线程就可以恢复执行任务。","tags":["AQS"],"title":"CountDownLatch 源码分析","translator":null,"url":"/blog/countdownlatch-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","weight":0,"wordcount":4569},{"author":"Siran","authorlink":null,"banner":"/img/blog/banners/00704eQkgy1fs0iwgalk7j30rs0kux38.jpg","categories":["分布式"],"date":"2020-02-05T12:12:42+08:00","fuzzywordcount":100,"keywords":["分布式"],"lang":"zh","lastmod":"2020-02-05T12:12:42+08:00","objectID":"c889e554dadb0d36285d68ba7f739dad","permalink":"/blog/raft-%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/","publishdate":"2020-02-05T12:12:42+08:00","readingtime":1,"relpermalink":"/blog/raft-%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/","summary":"","tags":["分布式"],"title":"Raft 思维导图","translator":null,"url":"/blog/raft-%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/","weight":0,"wordcount":10},{"author":"Siran","authorlink":null,"banner":"/img/blog/banners/00704eQkgy1fs77zshhihj30rs0kunab.jpg","categories":["AQS"],"date":"2020-02-05T11:12:42+08:00","fuzzywordcount":3100,"keywords":["AQS","Jdk源码","基础"],"lang":"zh","lastmod":"2020-02-05T11:12:42+08:00","objectID":"5506b1344d91c4832cfe728e859e5db2","permalink":"/blog/reentrantreadwritelock-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","publishdate":"2020-02-05T11:12:42+08:00","readingtime":7,"relpermalink":"/blog/reentrantreadwritelock-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","summary":"ReentrantReadWriteLock 是什么?","tags":["AQS"],"title":"ReentrantReadWriteLock 源码分析","translator":null,"url":"/blog/reentrantreadwritelock-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","weight":0,"wordcount":3053},{"author":"Siran","authorlink":null,"banner":"/img/blog/banners/006tKfTcly1g0aso107znj31400u04qr.jpg","categories":["AQS"],"date":"2020-02-04T19:12:42+08:00","fuzzywordcount":2500,"keywords":["AQS","Jdk源码","基础"],"lang":"zh","lastmod":"2020-02-04T19:12:42+08:00","objectID":"536e954769f974bc01ca1be31e626291","permalink":"/blog/cyclicbarrier-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","publishdate":"2020-02-04T19:12:42+08:00","readingtime":5,"relpermalink":"/blog/cyclicbarrier-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","summary":"CyclicBarrier(回声栅栏)根据Javadoc描述，它会阻塞一组线程直到这些线程同时达到某个条件才继续执行。它就像一个栅栏一样，当一组线程都到达了栅栏处才继续往下走。","tags":["AQS"],"title":"CyclicBarrier 源码分析","translator":null,"url":"/blog/cyclicbarrier-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","weight":0,"wordcount":2448},{"author":"Siran","authorlink":null,"banner":"/img/blog/banners/006tNbRwly1fyb51imvdpj31420u0hdt.jpg","categories":["线程池"],"date":"2020-01-18T19:12:42+08:00","fuzzywordcount":10500,"keywords":["线程池","基础"],"lang":"zh","lastmod":"2020-01-18T19:12:42+08:00","objectID":"e3016c8b45f83da6a29fc621b8ec6819","permalink":"/blog/threadpoolexecutor-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","publishdate":"2020-01-18T19:12:42+08:00","readingtime":21,"relpermalink":"/blog/threadpoolexecutor-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","summary":"ThreadPoolExecutor中常用参数有哪些，作用是什么？任务提交后，ThreadPoolExecutor会按照什么策略去创建线程用于执行提交任务？","tags":["线程池"],"title":"ThreadPoolExecutor 源码分析","translator":null,"url":"/blog/threadpoolexecutor-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","weight":0,"wordcount":10404},{"author":"Siran","authorlink":null,"banner":"/img/blog/banners/00704eQkgy1fs1hvk6nt7j30rs0kunjm.jpg","categories":["AQS"],"date":"2020-01-05T19:12:42+08:00","fuzzywordcount":6900,"keywords":["AQS","Jdk源码","基础"],"lang":"zh","lastmod":"2020-01-05T19:12:42+08:00","objectID":"ed25bacb217de233acedef084f931ec6","permalink":"/blog/reentrantlock-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","publishdate":"2020-01-05T19:12:42+08:00","readingtime":14,"relpermalink":"/blog/reentrantlock-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","summary":"通常使用锁就是 synchronized，经过 jdk 的一系列优化引入偏向锁、轻量级锁、重量级锁等概念，性能也是有很大的提高。","tags":["AQS"],"title":"ReentrantLock 源码分析","translator":null,"url":"/blog/reentrantlock-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","weight":0,"wordcount":6878},{"author":"Siran","authorlink":null,"banner":"/img/blog/banners/006tNc79ly1g1wro2nt88j31400u0u0z.jpg","categories":["线程池"],"date":"2020-01-05T12:12:42+08:00","fuzzywordcount":5300,"keywords":["线程池","基础"],"lang":"zh","lastmod":"2020-01-05T12:12:42+08:00","objectID":"d8b7bcd882c1adf2d4cf0696b7da89f2","permalink":"/blog/scheduledthreadpoolexecutor-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","publishdate":"2020-01-05T12:12:42+08:00","readingtime":11,"relpermalink":"/blog/scheduledthreadpoolexecutor-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","summary":"ScheduledThreadPoolExecutor 定义了一个延迟队列 DelayedWorkQueue，这个队列是基于二叉堆来实现的，每次都会把最快要执行的任务放入堆顶(最小堆)。","tags":["线程池"],"title":"ScheduledThreadPoolExecutor 源码分析","translator":null,"url":"/blog/scheduledthreadpoolexecutor-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","weight":0,"wordcount":5228},{"author":"Siran","authorlink":null,"banner":"/img/blog/banners/006tNc79ly1g2bd7nfv72j31400u0x6s.jpg","categories":["AQS"],"date":"2018-06-05T19:12:42+08:00","fuzzywordcount":2400,"keywords":["AQS","Jdk源码","基础"],"lang":"zh","lastmod":"2018-06-05T19:12:42+08:00","objectID":"50560b311ee5156e7e3f2e3a18dc3b20","permalink":"/blog/semaphore-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","publishdate":"2018-06-05T19:12:42+08:00","readingtime":5,"relpermalink":"/blog/semaphore-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","summary":"基于微服务的架构是未来的趋势，但是实现这种架构会面临许多困难。现代应用架构远比过去的架构复杂，因此实现微服务架构将会带来了一系列特殊的挑战，而服务网格可以帮我们解决很多问题。","tags":["AQS"],"title":"Semaphore 源码分析","translator":null,"url":"/blog/semaphore-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","weight":0,"wordcount":2368}]