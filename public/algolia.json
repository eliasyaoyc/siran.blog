[{"author":"Siran","authorlink":null,"banner":"/img/blog/banners/6ce41a46gy1g31wxsf5ibj20rs0ku10r.jpg","categories":["AQS","Jdk源码"],"date":"2020-03-01T19:12:42+08:00","fuzzywordcount":6000,"keywords":["AQS","Jdk源码","基础"],"lang":"zh","lastmod":"2020-03-01T19:12:42+08:00","objectID":"72974e4f008b51a315a717210742ed59","permalink":"/blog/condition-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","publishdate":"2020-03-01T19:12:42+08:00","readingtime":12,"relpermalink":"/blog/condition-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","summary":"Condition可以替代传统的Object中的wait()、notify()和notifyAll()方法来实现线程间的通信，使线程间协作更加安全和高效。","tags":["AQS"],"title":"Condition 源码分析","translator":null,"url":"/blog/condition-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","weight":0,"wordcount":5925},{"author":"Siran","authorlink":null,"banner":"/img/blog/banners/006tNbRwly1fug0hms6vej31jk15ou0x.jpg","categories":["线程池","Jdk源码"],"date":"2020-02-15T19:12:42+08:00","fuzzywordcount":3700,"keywords":["线程池","Jdk源码","基础"],"lang":"zh","lastmod":"2020-02-15T19:12:42+08:00","objectID":"3b921f9e230c93db823bbc058b55ec6d","permalink":"/blog/futuretask-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","publishdate":"2020-02-15T19:12:42+08:00","readingtime":8,"relpermalink":"/blog/futuretask-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","summary":"FutureTask 是一个可以取消的异步计算任务，实现Future，Runnable。提供超时控制、可以获取线程执行后的返回结果、可以取消。","tags":["线程池"],"title":"FutureTask 源码分析","translator":null,"url":"/blog/futuretask-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","weight":0,"wordcount":3616},{"author":"Siran","authorlink":null,"banner":"/img/blog/banners/00704eQkgy1fs2ua9kohvj30rs0kub29.jpg","categories":["分布式"],"date":"2020-02-13T19:12:42+08:00","fuzzywordcount":8000,"keywords":["分布式"],"lang":"zh","lastmod":"2020-02-13T19:12:42+08:00","objectID":"a590a4ab03b768512c00a5375f32b867","permalink":"/blog/raft-%E5%8D%8F%E8%AE%AE/","publishdate":"2020-02-13T19:12:42+08:00","readingtime":16,"relpermalink":"/blog/raft-%E5%8D%8F%E8%AE%AE/","summary":"Raft 是一种为了管理复制日志的一致性算法。它提供了和 Paxos 算法相同的功能和性能，但是比 Paxos 更容易理解并且更容易实现。","tags":["分布式"],"title":"Raft 协议","translator":null,"url":"/blog/raft-%E5%8D%8F%E8%AE%AE/","weight":0,"wordcount":7980},{"author":"Siran","authorlink":null,"banner":"/img/blog/banners/00704eQkgy1fs3o6ljkknj30rs0ku4qp.jpg","categories":["集合","Jdk源码"],"date":"2020-02-12T19:12:42+08:00","fuzzywordcount":2900,"keywords":["集合","Jdk源码","基础"],"lang":"zh","lastmod":"2020-02-12T19:12:42+08:00","objectID":"7b611e19d7e17791f3b935ae45648e41","permalink":"/blog/priorityqueue-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","publishdate":"2020-02-12T19:12:42+08:00","readingtime":6,"relpermalink":"/blog/priorityqueue-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","summary":"PriorityQueue里的每个元素都会进行排序，每次弹出一个元素要么是最大的要么是最小的，取决于排序规则。","tags":["集合"],"title":"PriorityQueue 源码分析","translator":null,"url":"/blog/priorityqueue-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","weight":0,"wordcount":2820},{"author":"Siran","authorlink":null,"banner":"/img/blog/banners/006tKfTcgy1ftdx65tgduj30rs0kugov.jpg","categories":["AQS","Jdk源码"],"date":"2020-02-05T19:12:42+08:00","fuzzywordcount":4600,"keywords":["AQS","Jdk源码","基础"],"lang":"zh","lastmod":"2020-02-05T19:12:42+08:00","objectID":"43b195108080cfe10b3a345267e24ef5","permalink":"/blog/countdownlatch-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","publishdate":"2020-02-05T19:12:42+08:00","readingtime":10,"relpermalink":"/blog/countdownlatch-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","summary":"CountDownLatch是通过一个计数器来实现的，计数器的初始值为线程的数量。每当一个线程完成了自己的任务后，计数器的值就会减1。当计数器值到达0时，它表示所有的线程已经完成了任务，然后在闭锁上等待的线程就可以恢复执行任务。","tags":["AQS"],"title":"CountDownLatch 源码分析","translator":null,"url":"/blog/countdownlatch-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","weight":0,"wordcount":4568},{"author":"Siran","authorlink":null,"banner":"/img/blog/banners/00704eQkgy1fs0iwgalk7j30rs0kux38.jpg","categories":["分布式"],"date":"2020-02-05T12:12:42+08:00","fuzzywordcount":100,"keywords":["分布式"],"lang":"zh","lastmod":"2020-02-05T12:12:42+08:00","objectID":"b2c1a0c084bdc76575d71df741925dac","permalink":"/blog/raft-%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/","publishdate":"2020-02-05T12:12:42+08:00","readingtime":1,"relpermalink":"/blog/raft-%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/","summary":"","tags":["分布式"],"title":"Raft 思维导图","translator":null,"url":"/blog/raft-%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/","weight":0,"wordcount":10},{"author":"Siran","authorlink":null,"banner":"/img/blog/banners/00704eQkgy1fs77zshhihj30rs0kunab.jpg","categories":["AQS","Jdk源码"],"date":"2020-02-05T11:12:42+08:00","fuzzywordcount":3100,"keywords":["AQS","Jdk源码","基础"],"lang":"zh","lastmod":"2020-02-05T11:12:42+08:00","objectID":"8a22697c52e22dbcac9be3f6e817898f","permalink":"/blog/reentrantreadwritelock-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","publishdate":"2020-02-05T11:12:42+08:00","readingtime":7,"relpermalink":"/blog/reentrantreadwritelock-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","summary":"ReentrantReadWriteLock 是什么?","tags":["AQS"],"title":"ReentrantReadWriteLock 源码分析","translator":null,"url":"/blog/reentrantreadwritelock-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","weight":0,"wordcount":3094},{"author":"Siran","authorlink":null,"banner":"/img/blog/banners/006tKfTcly1g0aso107znj31400u04qr.jpg","categories":["AQS","Jdk源码"],"date":"2020-02-04T19:12:42+08:00","fuzzywordcount":2500,"keywords":["AQS","Jdk源码","基础"],"lang":"zh","lastmod":"2020-02-04T19:12:42+08:00","objectID":"50925bdd7fff74b8752a50cbc0dab470","permalink":"/blog/cyclicbarrier-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","publishdate":"2020-02-04T19:12:42+08:00","readingtime":5,"relpermalink":"/blog/cyclicbarrier-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","summary":"CyclicBarrier(回声栅栏)根据Javadoc描述，它会阻塞一组线程直到这些线程同时达到某个条件才继续执行。它就像一个栅栏一样，当一组线程都到达了栅栏处才继续往下走。","tags":["AQS"],"title":"CyclicBarrier 源码分析","translator":null,"url":"/blog/cyclicbarrier-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","weight":0,"wordcount":2448},{"author":"Siran","authorlink":null,"banner":"/img/blog/banners/006tNbRwly1fyb51imvdpj31420u0hdt.jpg","categories":["线程池","Jdk源码"],"date":"2020-01-18T19:12:42+08:00","fuzzywordcount":9800,"keywords":["线程池","Jdk源码","基础"],"lang":"zh","lastmod":"2020-01-18T19:12:42+08:00","objectID":"caafccdb81c12638b0adcafb8787cb4a","permalink":"/blog/threadpoolexecutor-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","publishdate":"2020-01-18T19:12:42+08:00","readingtime":20,"relpermalink":"/blog/threadpoolexecutor-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","summary":"ThreadPoolExecutor中常用参数有哪些，作用是什么？任务提交后，ThreadPoolExecutor会按照什么策略去创建线程用于执行提交任务？","tags":["线程池"],"title":"ThreadPoolExecutor 源码分析","translator":null,"url":"/blog/threadpoolexecutor-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","weight":0,"wordcount":9741},{"author":"Siran","authorlink":null,"banner":"/img/blog/banners/00704eQkgy1fs1hvk6nt7j30rs0kunjm.jpg","categories":["AQS","Jdk源码"],"date":"2020-01-05T19:12:42+08:00","fuzzywordcount":7000,"keywords":["AQS","Jdk源码","基础"],"lang":"zh","lastmod":"2020-01-05T19:12:42+08:00","objectID":"18fa2ca34031938af1ced0e71ba27019","permalink":"/blog/reentrantlock-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","publishdate":"2020-01-05T19:12:42+08:00","readingtime":14,"relpermalink":"/blog/reentrantlock-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","summary":"通常使用锁就是 synchronized，经过 jdk 的一系列优化引入偏向锁、轻量级锁、重量级锁等概念，性能也是有很大的提高。","tags":["AQS"],"title":"ReentrantLock 源码分析","translator":null,"url":"/blog/reentrantlock-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","weight":0,"wordcount":6969},{"author":"Siran","authorlink":null,"banner":"/img/blog/banners/006tNc79ly1g1wro2nt88j31400u0u0z.jpg","categories":["线程池","Jdk源码"],"date":"2020-01-05T12:12:42+08:00","fuzzywordcount":5500,"keywords":["线程池","Jdk源码","基础"],"lang":"zh","lastmod":"2020-01-05T12:12:42+08:00","objectID":"a63a24d9925db487c50e09591c180641","permalink":"/blog/scheduledthreadpoolexecutor-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","publishdate":"2020-01-05T12:12:42+08:00","readingtime":11,"relpermalink":"/blog/scheduledthreadpoolexecutor-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","summary":"ScheduledThreadPoolExecutor 定义了一个延迟队列 DelayedWorkQueue，这个队列是基于二叉堆来实现的，每次都会把最快要执行的任务放入堆顶(最小堆)。","tags":["线程池"],"title":"ScheduledThreadPoolExecutor 源码分析","translator":null,"url":"/blog/scheduledthreadpoolexecutor-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","weight":0,"wordcount":5408},{"author":"Siran","authorlink":null,"banner":"/img/blog/banners/006tNc79ly1g2bd7nfv72j31400u0x6s.jpg","categories":["线程池","Jdk源码"],"date":"2018-06-05T19:12:42+08:00","fuzzywordcount":2400,"keywords":["线程池","Jdk源码","基础"],"lang":"zh","lastmod":"2018-06-05T19:12:42+08:00","objectID":"4e8b3d53eef6a8ff5638f89a1ab96fb2","permalink":"/blog/semaphore-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","publishdate":"2018-06-05T19:12:42+08:00","readingtime":5,"relpermalink":"/blog/semaphore-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","summary":"基于微服务的架构是未来的趋势，但是实现这种架构会面临许多困难。现代应用架构远比过去的架构复杂，因此实现微服务架构将会带来了一系列特殊的挑战，而服务网格可以帮我们解决很多问题。","tags":["线程池"],"title":"Semaphore 源码分析","translator":null,"url":"/blog/semaphore-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","weight":0,"wordcount":2368}]